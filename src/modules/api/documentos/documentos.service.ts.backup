import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { UnitOfWorkService } from '@/modules/config/unit_of_work/uow.service';
import { Documentos } from '@/modules/config/entities/documentos.entity';
import { TurmasAlunosTreinamentosContratos } from '@/modules/config/entities/turmasAlunosTreinamentosContratos.entity';
import { EStatusAssinaturasContratos } from '@/modules/config/entities/enum';
import * as crypto from 'crypto';
import axios from 'axios';
import { Not, IsNull } from 'typeorm';
import {
    CreateDocumentoDto,
    UpdateDocumentoDto,
    DocumentoResponseDto,
    DocumentosListResponseDto,
    GerarContratoDto,
    CampoDocumentoDto,
    DocumentosFilterDto,
    CriarContratoZapSignDto,
    RespostaContratoZapSignDto,
    AtualizarStatusContratoDto,
} from './dto/documentos.dto';
import { ETipoDocumento, EFormasPagamento } from '@/modules/config/entities/enum';
import { ZapSignService } from './zapsign.service';
import { ContractTemplateService } from './contract-template.service';
import * as PDFDocument from 'pdfkit';

@Injectable()
export class DocumentosService {
    constructor(
        private readonly uow: UnitOfWorkService,
        private readonly zapSignService: ZapSignService,
        private readonly contractTemplateService: ContractTemplateService,
    ) {}

    async createDocumento(createDocumentoDto: CreateDocumentoDto, userId?: number): Promise<DocumentoResponseDto> {
        try {
            console.log('üìÑ [BACKEND] Criando documento com treinamentos relacionados:', createDocumentoDto.treinamentos_relacionados);

            const documento = this.uow.documentosRP.create({
                documento: createDocumentoDto.documento,
                tipo_documento: createDocumentoDto.tipo_documento,
                campos: createDocumentoDto.campos,
                clausulas: createDocumentoDto.clausulas,
                treinamentos_relacionados: createDocumentoDto.treinamentos_relacionados || [],
                criado_por: userId,
                atualizado_por: userId,
            });

            const savedDocumento = await this.uow.documentosRP.save(documento);
            console.log('‚úÖ [BACKEND] Documento criado com treinamentos:', savedDocumento.treinamentos_relacionados);
            return this.mapToResponseDto(savedDocumento);
        } catch (error) {
            console.error('Erro ao criar documento:', error);
            throw new BadRequestException('Erro ao criar documento');
        }
    }

    async findAllDocumentos(page: number = 1, limit: number = 10, filter?: DocumentosFilterDto): Promise<DocumentosListResponseDto> {
        try {
            const whereCondition: any = { deletado_em: null }; // Excluir documentos deletados (soft delete)

            // Filtrar por tipo de documento se especificado
            if (filter?.tipo_documento) {
                whereCondition.tipo_documento = filter.tipo_documento;
            }

            const [documentos, total] = await this.uow.documentosRP.findAndCount({
                where: whereCondition,
                order: { documento: 'ASC' },
                skip: (page - 1) * limit,
                take: limit,
            });

            const data = documentos.map((doc) => this.mapToResponseDto(doc));
            const totalPages = Math.ceil(total / limit);

            return {
                data,
                total,
                page,
                limit,
                totalPages,
            };
        } catch (error) {
            console.error('Erro ao buscar documentos:', error);
            throw new BadRequestException('Erro ao buscar documentos');
        }
    }

    async findDocumentoById(id: number): Promise<DocumentoResponseDto> {
        try {
            const documento = await this.uow.documentosRP.findOne({
                where: { id, deletado_em: null }, // Excluir documentos deletados (soft delete)
            });

            if (!documento) {
                throw new NotFoundException('Documento n√£o encontrado');
            }

            return this.mapToResponseDto(documento);
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw error;
            }
            console.error('Erro ao buscar documento:', error);
            throw new BadRequestException('Erro ao buscar documento');
        }
    }

    async updateDocumento(id: number, updateDocumentoDto: UpdateDocumentoDto, userId?: number): Promise<DocumentoResponseDto> {
        try {
            const documento = await this.uow.documentosRP.findOne({
                where: { id, deletado_em: null }, // Excluir documentos deletados (soft delete)
            });

            if (!documento) {
                throw new NotFoundException('Documento n√£o encontrado');
            }

            // Atualizar campos fornecidos
            if (updateDocumentoDto.documento !== undefined) {
                documento.documento = updateDocumentoDto.documento;
            }
            if (updateDocumentoDto.tipo_documento !== undefined) {
                documento.tipo_documento = updateDocumentoDto.tipo_documento;
            }
            if (updateDocumentoDto.campos !== undefined) {
                documento.campos = updateDocumentoDto.campos;
            }
            if (updateDocumentoDto.clausulas !== undefined) {
                documento.clausulas = updateDocumentoDto.clausulas;
            }
            if (updateDocumentoDto.treinamentos_relacionados !== undefined) {
                console.log('üìù [BACKEND] Atualizando treinamentos relacionados:', updateDocumentoDto.treinamentos_relacionados);
                documento.treinamentos_relacionados = updateDocumentoDto.treinamentos_relacionados;
            }

            // Atualizar auditoria
            documento.atualizado_por = userId;

            const savedDocumento = await this.uow.documentosRP.save(documento);
            console.log('‚úÖ [BACKEND] Documento atualizado com treinamentos:', savedDocumento.treinamentos_relacionados);
            return this.mapToResponseDto(savedDocumento);
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw error;
            }
            console.error('Erro ao atualizar documento:', error);
            throw new BadRequestException('Erro ao atualizar documento');
        }
    }

    async deleteDocumento(id: number, userId?: number): Promise<{ message: string }> {
        try {
            const documento = await this.uow.documentosRP.findOne({
                where: { id, deletado_em: null }, // Excluir documentos j√° deletados
            });

            if (!documento) {
                throw new NotFoundException('Documento n√£o encontrado');
            }

            // Soft delete - apenas marca como deletado
            documento.deletado_em = new Date();
            documento.atualizado_por = userId;

            await this.uow.documentosRP.save(documento);
            return { message: 'Documento removido com sucesso' };
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw error;
            }
            console.error('Erro ao remover documento:', error);
            throw new BadRequestException('Erro ao remover documento');
        }
    }

    async duplicateDocumento(id: number, userId?: number): Promise<DocumentoResponseDto> {
        try {
            const documentoOriginal = await this.uow.documentosRP.findOne({
                where: { id, deletado_em: null }, // Excluir documentos deletados
            });

            if (!documentoOriginal) {
                throw new NotFoundException('Documento n√£o encontrado');
            }

            // Criar novo documento baseado no original
            const novoDocumento = this.uow.documentosRP.create({
                documento: `${documentoOriginal.documento} (C√≥pia)`,
                tipo_documento: documentoOriginal.tipo_documento,
                campos: documentoOriginal.campos,
                clausulas: documentoOriginal.clausulas,
                treinamentos_relacionados: documentoOriginal.treinamentos_relacionados || [],
                criado_por: userId,
                atualizado_por: userId,
            });

            const savedDocumento = await this.uow.documentosRP.save(novoDocumento);
            return this.mapToResponseDto(savedDocumento);
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw error;
            }
            console.error('Erro ao duplicar documento:', error);
            throw new BadRequestException('Erro ao duplicar documento');
        }
    }

    async gerarContrato(gerarContratoDto: GerarContratoDto): Promise<{ contrato: string; campos: any }> {
        try {
            const documento = await this.uow.documentosRP.findOne({
                where: { id: parseInt(gerarContratoDto.id_documento), deletado_em: null }, // Excluir documentos deletados
            });

            if (!documento) {
                throw new NotFoundException('Documento n√£o encontrado');
            }

            // Processar campos do documento
            let contratoProcessado = documento.clausulas;
            const camposProcessados: any = {};

            // Substituir placeholders pelos valores fornecidos
            for (const valorCampo of gerarContratoDto.valoresCampos) {
                const placeholder = `{{${valorCampo.nome}}}`;
                contratoProcessado = contratoProcessado.replace(new RegExp(placeholder, 'g'), valorCampo.valor);
                camposProcessados[valorCampo.nome] = valorCampo.valor;
            }

            return {
                contrato: contratoProcessado,
                campos: camposProcessados,
            };
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw error;
            }
            console.error('Erro ao gerar contrato:', error);
            throw new BadRequestException('Erro ao gerar contrato');
        }
    }

    private mapToResponseDto(documento: Documentos): DocumentoResponseDto {
        return {
            id: documento.id,
            documento: documento.documento,
            tipo_documento: documento.tipo_documento,
            campos: documento.campos || [],
            clausulas: documento.clausulas,
            treinamentos_relacionados: documento.treinamentos_relacionados || [],
            created_at: documento.criado_em,
            updated_at: documento.atualizado_em,
            criado_por: documento.criado_por,
            atualizado_por: documento.atualizado_por,
            deletado_em: documento.deletado_em,
        };
    }

    // M√©todo para extrair campos de um template de contrato
    extrairCamposDeTemplate(template: string): CampoDocumentoDto[] {
        const campos: CampoDocumentoDto[] = [];
        const regex = /\{\{([^}]+)\}\}/g;
        let match;

        while ((match = regex.exec(template)) !== null) {
            const nomeCampo = match[1].trim();

            // Verificar se o campo j√° foi processado
            if (!campos.find((campo) => campo.campo === nomeCampo)) {
                // Determinar o tipo do campo baseado no nome
                const tipo = this.determinarTipoCampo(nomeCampo);

                campos.push({
                    campo: nomeCampo,
                    tipo: tipo,
                    descricao: this.gerarDescricaoCampo(nomeCampo),
                });
            }
        }

        return campos;
    }

    private determinarTipoCampo(nomeCampo: string): string {
        const nome = nomeCampo.toLowerCase();

        if (nome.includes('data') || nome.includes('date')) return 'data';
        if (nome.includes('email') || nome.includes('e-mail')) return 'email';
        if (nome.includes('whatsapp') || nome.includes('telefone') || nome.includes('celular')) return 'telefone';
        if (nome.includes('cpf') || nome.includes('cnpj') || nome.includes('documento')) return 'documento';
        if (nome.includes('cep')) return 'cep';
        if (nome.includes('pre√ßo') || nome.includes('valor') || nome.includes('valor')) return 'numero';
        if (nome.includes('checkbox') || nome.includes('aplica') || nome.includes('selecionar')) return 'checkbox';
        if (nome.includes('quantidade') || nome.includes('parcelas')) return 'numero';

        return 'texto';
    }

    private gerarDescricaoCampo(nomeCampo: string): string {
        const nome = nomeCampo.toLowerCase();

        if (nome.includes('nome')) return 'Nome completo';
        if (nome.includes('data nascimento')) return 'Data de nascimento';
        if (nome.includes('endere√ßo')) return 'Endere√ßo completo';
        if (nome.includes('cidade')) return 'Cidade';
        if (nome.includes('estado')) return 'Estado';
        if (nome.includes('treinamento')) return 'Nome do treinamento';
        if (nome.includes('pre√ßo')) return 'Pre√ßo do contrato';
        if (nome.includes('data prevista')) return 'Data prevista do treinamento';

        return nomeCampo;
    }

    // M√©todo para gerar PDF real usando PDFKit
    private gerarPDFReal(titulo: string, conteudo: string): Promise<string> {
        const doc = new PDFDocument({
            size: 'A4',
            margins: {
                top: 50,
                bottom: 50,
                left: 50,
                right: 50,
            },
        });

        const buffers: Buffer[] = [];
        doc.on('data', buffers.push.bind(buffers));

        return new Promise((resolve, reject) => {
            doc.on('end', () => {
                const pdfBuffer = Buffer.concat(buffers);
                resolve(pdfBuffer.toString('base64'));
            });

            doc.on('error', reject);

            // T√≠tulo
            doc.fontSize(18).font('Helvetica-Bold').text(titulo, { align: 'center' }).moveDown(2);

            // Conte√∫do
            doc.fontSize(12).font('Helvetica').text(conteudo, {
                align: 'justify',
                lineGap: 5,
            });

            doc.end();
        });
    }

    // M√©todos para integra√ß√£o com ZapSign
    async buscarTemplatesZapSign() {
        try {
            console.log('Iniciando busca de documentos para templates...');

            // Buscar documentos do banco de dados local
            const documentos = await this.uow.documentosRP.find({
                where: { deletado_em: null },
                select: ['id', 'documento', 'tipo_documento', 'campos', 'clausulas', 'criado_em', 'atualizado_em'],
                order: { documento: 'ASC' },
            });

            console.log('Documentos encontrados:', documentos.length);
            console.log('Primeiros documentos:', documentos.slice(0, 3));

            const resultado = documentos.map((doc) => ({
                id: doc.id.toString(),
                name: doc.documento,
                tipo_documento: doc.tipo_documento,
                campos: doc.campos || [],
                clausulas: doc.clausulas || '',
                created_at: doc.criado_em,
                updated_at: doc.atualizado_em,
            }));

            console.log('Resultado final:', resultado.length, 'documentos processados');
            return resultado;
        } catch (error) {
            console.error('Erro ao buscar documentos do banco:', error);
            throw new BadRequestException('Erro ao buscar documentos');
        }
    }

    async buscarTemplatesZapSignReais() {
        try {
            console.log('Buscando templates reais do ZapSign...');
            const templates = await this.zapSignService.getTemplates();
            console.log('Templates do ZapSign encontrados:', templates.length);
            return templates;
        } catch (error) {
            console.error('Erro ao buscar templates do ZapSign:', error);
            throw new BadRequestException('Erro ao buscar templates do ZapSign');
        }
    }

    async buscarAluno(query: string) {
        try {
            if (!query || query.length < 3) {
                return [];
            }

            const alunos = await this.uow.alunosRP
                .createQueryBuilder('aluno')
                .where('aluno.deletado_em IS NULL')
                .andWhere('(aluno.nome ILIKE :query OR aluno.email ILIKE :query OR aluno.cpf ILIKE :query)', { query: `%${query}%` })
                .limit(10)
                .getMany();

            return alunos.map((aluno) => ({
                id: aluno.id.toString(),
                nome: aluno.nome,
                email: aluno.email,
                cpf: aluno.cpf,
                telefone_um: aluno.telefone_um,
            }));
        } catch (error) {
            console.error('Erro ao buscar aluno:', error);
            throw new BadRequestException('Erro ao buscar aluno');
        }
    }

    async criarContratoZapSign(criarContratoDto: CriarContratoZapSignDto, userId?: number): Promise<RespostaContratoZapSignDto> {
        try {
            // Buscar dados do aluno
            const aluno = await this.uow.alunosRP.findOne({
                where: { id: parseInt(criarContratoDto.id_aluno), deletado_em: null },
                relations: ['id_polo_fk'],
            });

            if (!aluno) {
                throw new NotFoundException('Aluno n√£o encontrado');
            }

            // Buscar dados do treinamento
            const treinamento = await this.uow.treinamentosRP.findOne({
                where: { id: parseInt(criarContratoDto.id_treinamento), deletado_em: null },
            });

            if (!treinamento) {
                throw new NotFoundException('Treinamento n√£o encontrado');
            }

            // Buscar dados da turma de IPR se fornecida
            let turma = null;
            if (criarContratoDto.id_turma_bonus) {
                turma = await this.uow.turmasRP.findOne({
                    where: { id: parseInt(criarContratoDto.id_turma_bonus), deletado_em: null },
                    relations: ['lider_evento_fk'],
                });
            }

            // Preparar dados para o template
            const templateData = this.prepareTemplateData(aluno, treinamento, turma, criarContratoDto);

            // Gerar PDF usando o novo template
            const pdfBuffer = await this.contractTemplateService.generateContractPDF(templateData);

            // Preparar signers (aluno + testemunhas)
            const signers = [
                {
                    name: aluno.nome,
                    email: aluno.email,
                    phone: aluno.telefone_um,
                    action: 'sign' as const,
                },
            ];

            // Adicionar testemunhas se fornecidas
            if (criarContratoDto.testemunha_um_id) {
                const testemunhaUm = await this.uow.alunosRP.findOne({
                    where: { id: parseInt(criarContratoDto.testemunha_um_id), deletado_em: null },
                });
                if (testemunhaUm) {
                    signers.push({
                        name: testemunhaUm.nome,
                        email: testemunhaUm.email,
                        phone: testemunhaUm.telefone_um,
                        action: 'sign' as const,
                    });
                }
            } else if (criarContratoDto.testemunha_um_nome && criarContratoDto.testemunha_um_cpf) {
                signers.push({
                    name: criarContratoDto.testemunha_um_nome,
                    email: `${criarContratoDto.testemunha_um_cpf}@testemunha.local`,
                    phone: '',
                    action: 'sign' as const,
                });
            }

            if (criarContratoDto.testemunha_dois_id) {
                const testemunhaDois = await this.uow.alunosRP.findOne({
                    where: { id: parseInt(criarContratoDto.testemunha_dois_id), deletado_em: null },
                });
                if (testemunhaDois) {
                    signers.push({
                        name: testemunhaDois.nome,
                        email: testemunhaDois.email,
                        phone: testemunhaDois.telefone_um,
                        action: 'sign' as const,
                    });
                }
            } else if (criarContratoDto.testemunha_dois_nome && criarContratoDto.testemunha_dois_cpf) {
                signers.push({
                    name: criarContratoDto.testemunha_dois_nome,
                    email: `${criarContratoDto.testemunha_dois_cpf}@testemunha.local`,
                    phone: '',
                    action: 'sign' as const,
                });
            }

            // Criar documento no ZapSign usando o PDF gerado
            const documentData = {
                name: `Contrato ${treinamento.nome} - ${aluno.nome}`,
                signers: signers,
                message: 'Por favor, assine este contrato de treinamento.',
                sandbox: false,
                file: pdfBuffer,
            };

            const zapSignResponse = await this.zapSignService.createDocumentFromFile(documentData);

            // Salvar informa√ß√µes do contrato no banco de dados
            const contrato = this.uow.turmasAlunosTreinamentosContratosRP.create({
                id_aluno_fk: aluno.id,
                id_treinamento_fk: treinamento.id,
                id_turma_fk: turma?.id || null,
                status_assinatura: EStatusAssinaturasContratos.PENDENTE,
                documento_zapsign_id: zapSignResponse.id,
                documento_zapsign_url: zapSignResponse.url,
                formas_pagamento: JSON.stringify(this.processPaymentMethods(criarContratoDto)),
                bonus_selecionados: JSON.stringify(criarContratoDto.tipos_bonus || []),
                valores_bonus: JSON.stringify(criarContratoDto.valores_bonus || {}),
                campos_variaveis: JSON.stringify(criarContratoDto.campos_variaveis || {}),
                observacoes: criarContratoDto.observacoes || '',
                criado_por: userId,
                atualizado_por: userId,
            });

            const savedContrato = await this.uow.turmasAlunosTreinamentosContratosRP.save(contrato);

            return {
                success: true,
                message: 'Contrato criado com sucesso no ZapSign',
                contrato_id: savedContrato.id,
                zapsign_document_id: zapSignResponse.id,
                zapsign_document_url: zapSignResponse.url,
                signers: signers,
            };
        } catch (error) {
            console.error('Erro ao criar contrato no ZapSign:', error);
            throw new BadRequestException(`Erro ao criar contrato: ${error.message}`);
        }
    }

    /**
     * Prepara os dados para o template do contrato
     */
    private prepareTemplateData(aluno: any, treinamento: any, turma: any, criarContratoDto: CriarContratoZapSignDto) {
        return {
            aluno: {
                nome: aluno.nome,
                cpf: this.contractTemplateService.formatCPF(aluno.cpf),
                data_nascimento: this.contractTemplateService.formatDate(aluno.data_nascimento),
                telefone_um: aluno.telefone_um,
                email: aluno.email,
                endereco: aluno.endereco,
                cidade_estado: `${aluno.cidade}/${aluno.estado}`,
                cep: this.contractTemplateService.formatCEP(aluno.cep),
            },
            treinamento: {
                nome: treinamento.nome,
                cidade: treinamento.cidade || 'Americana/SP',
                data_inicio: this.contractTemplateService.formatDate(treinamento.data_inicio),
                data_fim: this.contractTemplateService.formatDate(treinamento.data_fim),
                preco_formatado: this.contractTemplateService.formatPrice(treinamento.preco_treinamento),
            },
            bonus: {
                nao_aplica: criarContratoDto.tipos_bonus?.includes('nao_aplica') || false,
                cem_dias: criarContratoDto.tipos_bonus?.includes('cem_dias') || false,
                ipr: criarContratoDto.tipos_bonus?.includes('ipr') || false,
                ipr_data: turma ? this.contractTemplateService.formatDate(turma.data_inicio) : '',
                outros: criarContratoDto.tipos_bonus?.includes('outros') || false,
                outros_descricao: criarContratoDto.campos_variaveis?.outros_descricao || '',
            },
            pagamento: {
                cartao_credito_avista: this.isPaymentMethodSelected(criarContratoDto, '√Ä Vista - Cart√£o de Cr√©dito'),
                cartao_debito_avista: this.isPaymentMethodSelected(criarContratoDto, '√Ä Vista - Cart√£o de D√©bito'),
                pix_avista: this.isPaymentMethodSelected(criarContratoDto, '√Ä Vista - PIX/Transfer√™ncia'),
                especie_avista: this.isPaymentMethodSelected(criarContratoDto, '√Ä Vista - Esp√©cie'),
                cartao_credito_parcelado: this.isPaymentMethodSelected(criarContratoDto, 'Parcelado - Cart√£o de Cr√©dito'),
                boleto_parcelado: this.isPaymentMethodSelected(criarContratoDto, 'Parcelado - Boleto'),
            },
            observacoes: criarContratoDto.observacoes || '',
            contrato: {
                local: 'Americana/SP',
                data: this.contractTemplateService.formatDate(new Date()),
            },
            testemunhas: {
                testemunha_1: {
                    nome: criarContratoDto.testemunha_um_nome || '',
                    cpf: this.contractTemplateService.formatCPF(criarContratoDto.testemunha_um_cpf || ''),
                },
                testemunha_2: {
                    nome: criarContratoDto.testemunha_dois_nome || '',
                    cpf: this.contractTemplateService.formatCPF(criarContratoDto.testemunha_dois_cpf || ''),
                },
            },
        };
    }

    /**
     * Verifica se uma forma de pagamento foi selecionada
     */
    private isPaymentMethodSelected(criarContratoDto: CriarContratoZapSignDto, methodName: string): boolean {
        if (!criarContratoDto.valores_formas_pagamento) return false;
        return !!criarContratoDto.valores_formas_pagamento[methodName];
    }

    /**
     * Processa as formas de pagamento para salvar no banco
     */
    private processPaymentMethods(criarContratoDto: CriarContratoZapSignDto): any[] {
        const formasPagamento: any[] = [];

        if (criarContratoDto.forma_pagamento === 'A_VISTA' && criarContratoDto.valores_formas_pagamento) {
            const valoresFormas = criarContratoDto.valores_formas_pagamento;

            if (valoresFormas['√Ä Vista - Cart√£o de Cr√©dito']) {
                formasPagamento.push({
                    tipo: 'A_VISTA',
                    forma: 'CARTAO_CREDITO',
                    valor: parseInt(valoresFormas['√Ä Vista - Cart√£o de Cr√©dito'].valor) / 100,
                });
            }

            if (valoresFormas['√Ä Vista - Cart√£o de D√©bito']) {
                formasPagamento.push({
                    tipo: 'A_VISTA',
                    forma: 'CARTAO_DEBITO',
                    valor: parseInt(valoresFormas['√Ä Vista - Cart√£o de D√©bito'].valor) / 100,
                });
            }

            if (valoresFormas['√Ä Vista - PIX/Transfer√™ncia']) {
                formasPagamento.push({
                    tipo: 'A_VISTA',
                    forma: 'PIX',
                    valor: parseInt(valoresFormas['√Ä Vista - PIX/Transfer√™ncia'].valor) / 100,
                });
            }

            if (valoresFormas['√Ä Vista - Esp√©cie']) {
                formasPagamento.push({
                    tipo: 'A_VISTA',
                    forma: 'DINHEIRO',
                    valor: parseInt(valoresFormas['√Ä Vista - Esp√©cie'].valor) / 100,
                });
            }
        } else if (criarContratoDto.forma_pagamento === 'PARCELADO' && criarContratoDto.valores_formas_pagamento) {
            const valoresFormas = criarContratoDto.valores_formas_pagamento;

            if (valoresFormas['Parcelado - Cart√£o de Cr√©dito']) {
                const valorParcelado = parseInt(valoresFormas['Parcelado - Cart√£o de Cr√©dito'].valor) / 100;
                const numeroParcelas = parseInt(valoresFormas['Parcelado - Cart√£o de Cr√©dito'].numero_parcelas);
                const valorParcela = valorParcelado / numeroParcelas;

                for (let i = 0; i < numeroParcelas; i++) {
                    formasPagamento.push({
                        tipo: 'PARCELADO',
                        forma: 'CARTAO_CREDITO',
                        valor: valorParcela,
                    });
                }
            }

            if (valoresFormas['Parcelado - Boleto']) {
                const dadosBoleto = valoresFormas['Parcelado - Boleto'];
                const valorTotal = parseInt(dadosBoleto.valor_parcelas) / 100;
                const numeroParcelas = parseInt(dadosBoleto.numero_parcelas);
                const valorParcela = valorTotal / numeroParcelas;

                for (let i = 0; i < numeroParcelas; i++) {
                    formasPagamento.push({
                        tipo: 'PARCELADO',
                        forma: 'BOLETO',
                        valor: valorParcela,
                    });
                }
            }
        }

        return formasPagamento;
    }

                if (turmaExistente) {
                    turmaIdParaContrato = turmaExistente.id;
                    console.log('Usando turma existente:', turmaIdParaContrato);
                } else {
                    // Se n√£o h√° turma para o treinamento, buscar qualquer turma v√°lida
                    const turmaQualquer = await this.uow.turmasRP.findOne({
                        where: {
                            deletado_em: null,
                        },
                        order: {
                            criado_em: 'DESC',
                        },
                    });

                    if (turmaQualquer) {
                        turmaIdParaContrato = turmaQualquer.id;
                        console.log('Usando turma gen√©rica:', turmaIdParaContrato);
                    } else {
                        throw new Error('Nenhuma turma v√°lida encontrada no sistema');
                    }
                }
            }

            // Criar registro de turma_aluno se n√£o existir
            let turmaAluno = await this.uow.turmasAlunosRP.findOne({
                where: {
                    id_aluno: criarContratoDto.id_aluno,
                    id_turma: turmaIdParaContrato,
                },
            });

            if (!turmaAluno) {
                // Criar registro de turma_aluno
                turmaAluno = this.uow.turmasAlunosRP.create({
                    id_turma: turmaIdParaContrato,
                    id_aluno: criarContratoDto.id_aluno,
                    nome_cracha: aluno.nome,
                    numero_cracha: `CR${Date.now()}`, // N√∫mero √∫nico para o crach√°
                    criado_por: userId,
                    atualizado_por: userId,
                });
                turmaAluno = await this.uow.turmasAlunosRP.save(turmaAluno);
                console.log('Registro turma_aluno criado:', turmaAluno.id);
            }

            // Criar registro de treinamento do aluno
            console.log('Dados para criar turmaAlunoTreinamento:', {
                id_turma_aluno: turmaAluno.id,
                id_treinamento: parseInt(criarContratoDto.id_treinamento),
                preco_treinamento: treinamento.preco_treinamento,
                forma_pgto: formasPagamento,
                preco_total_pago: precoTotal,
            });

            const turmaAlunoTreinamento = this.uow.turmasAlunosTreinamentosRP.create({
                id_turma_aluno: turmaAluno.id, // Usar o ID real da turma_aluno
                id_treinamento: parseInt(criarContratoDto.id_treinamento),
                preco_treinamento: treinamento.preco_treinamento,
                forma_pgto: formasPagamento,
                preco_total_pago: precoTotal,
                criado_por: userId,
                atualizado_por: userId,
            });

            const turmaAlunoTreinamentoSalvo = await this.uow.turmasAlunosTreinamentosRP.save(turmaAlunoTreinamento);

            // Compilar todos os dados do contrato para armazenamento
            const dadosContrato = this.compilarDadosContrato(criarContratoDto, aluno, treinamento, turma, formasPagamento, template, documentoConteudo);

            // Criar registro de contrato
            const contrato = this.uow.turmasAlunosTreinamentosContratosRP.create({
                id_turma_aluno_treinamento: turmaAlunoTreinamentoSalvo.id,
                id_documento: parseInt(criarContratoDto.template_id),
                status_ass_aluno: 'ASSINATURA_PENDENTE' as any,
                data_ass_aluno: null, // Ser√° preenchida apenas quando o aluno assinar
                testemunha_um: criarContratoDto.testemunha_um_id ? parseInt(criarContratoDto.testemunha_um_id) : null,
                status_ass_test_um: 'ASSINATURA_PENDENTE' as any,
                data_ass_test_um: null, // Ser√° preenchida apenas quando a testemunha assinar
                testemunha_dois: criarContratoDto.testemunha_dois_id ? parseInt(criarContratoDto.testemunha_dois_id) : null,
                status_ass_test_dois: 'ASSINATURA_PENDENTE' as any,
                data_ass_test_dois: null, // Ser√° preenchida apenas quando a testemunha assinar
                dados_contrato: dadosContrato,
                criado_por: userId,
                atualizado_por: userId,
            });

            const contratoSalvo = await this.uow.turmasAlunosTreinamentosContratosRP.save(contrato);
            console.log('üíæ Contrato inicial salvo com ID:', contratoSalvo.id);

            // Validar se o documento do ZapSign tem token (ID √∫nico)
            if (!documentoZapSign.token) {
                console.error('‚ùå ERRO CR√çTICO: documentoZapSign n√£o possui token!');
                console.error('documentoZapSign:', JSON.stringify(documentoZapSign, null, 2));
                throw new BadRequestException('Erro ao criar contrato: ZapSign n√£o retornou um token v√°lido');
            }

            console.log('‚úÖ Token do documento ZapSign v√°lido:', documentoZapSign.token);
            console.log('‚úÖ Open ID do documento ZapSign:', documentoZapSign.open_id);

            // Atualizar o objeto dados_contrato com o token do ZapSign e informa√ß√µes das testemunhas
            const dadosContratoAtualizado = { ...dadosContrato };

            // Adicionar token do ZapSign (ID √∫nico do documento)
            dadosContratoAtualizado.contrato.id_documento_zapsign = documentoZapSign.token;
            console.log('üìù Token do ZapSign adicionado aos dados_contrato:', documentoZapSign.token);

            // Preencher informa√ß√µes das testemunhas se forem do banco
            if (criarContratoDto.testemunha_um_id) {
                const testemunhaUm = await this.uow.alunosRP.findOne({
                    where: { id: parseInt(criarContratoDto.testemunha_um_id), deletado_em: null },
                });
                if (testemunhaUm) {
                    dadosContratoAtualizado.testemunhas.testemunha_um.email = testemunhaUm.email;
                    dadosContratoAtualizado.testemunhas.testemunha_um.telefone = testemunhaUm.telefone_um;
                }
            }

            if (criarContratoDto.testemunha_dois_id) {
                const testemunhaDois = await this.uow.alunosRP.findOne({
                    where: { id: parseInt(criarContratoDto.testemunha_dois_id), deletado_em: null },
                });
                if (testemunhaDois) {
                    dadosContratoAtualizado.testemunhas.testemunha_dois.email = testemunhaDois.email;
                    dadosContratoAtualizado.testemunhas.testemunha_dois.telefone = testemunhaDois.telefone_um;
                }
            }

            // Atualizar o registro com os dados completos
            contratoSalvo.dados_contrato = dadosContratoAtualizado;

            console.log('üîÑ Atualizando contrato no banco com dados do ZapSign...');
            console.log('   - Contrato ID:', contratoSalvo.id);
            console.log('   - ZapSign Document Token:', documentoZapSign.token);
            console.log('   - ZapSign Open ID:', documentoZapSign.open_id);
            console.log('   - Status:', documentoZapSign.status);

            // Salvar dados espec√≠ficos do ZapSign nos campos da entidade
            const updateResult = await this.uow.turmasAlunosTreinamentosContratosRP.update(
                { id: contratoSalvo.id },
                {
                    dados_contrato: dadosContratoAtualizado,
                    zapsign_document_id: documentoZapSign.token, // Usar token como ID √∫nico
                    zapsign_signers_data: documentoZapSign.signers || [],
                    zapsign_document_status: {
                        documentId: documentoZapSign.token,
                        openId: documentoZapSign.open_id,
                        signers: documentoZapSign.signers || [],
                        status: documentoZapSign.status,
                        createdAt: documentoZapSign.created_at,
                        originalFile: documentoZapSign.original_file,
                        signedFile: documentoZapSign.signed_file,
                    },
                },
            );

            console.log('‚úÖ Contrato atualizado! Resultado:', updateResult);

            // Buscar o contrato atualizado para confirmar que foi salvo corretamente
            const contratoAtualizado = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoSalvo.id },
            });

            console.log('üîç Verificando dados salvos no banco:');
            console.log('   - zapsign_document_id salvo:', contratoAtualizado?.zapsign_document_id);
            console.log('   - zapsign_document_status salvo:', contratoAtualizado?.zapsign_document_status ? 'SIM' : 'N√ÉO');
            console.log(
                '   - zapsign_signers_data salvo:',
                contratoAtualizado?.zapsign_signers_data ? `${contratoAtualizado.zapsign_signers_data.length} signat√°rios` : 'N√ÉO',
            );

            if (!contratoAtualizado?.zapsign_document_id) {
                console.error('‚ùå ERRO: zapsign_document_id n√£o foi salvo no banco!');
                throw new BadRequestException('Erro ao salvar ID do ZapSign no banco de dados');
            }

            console.log('‚úÖ Todos os dados do ZapSign foram salvos corretamente!');

            // Retornar resposta formatada
            return {
                id: documentoZapSign.token, // Usar token como ID
                nome_documento: nomeDocumento,
                status: documentoZapSign.status,
                url_assinatura: documentoZapSign.signers[0]?.sign_url || undefined,
                signers: documentoZapSign.signers.map((signer) => ({
                    nome: signer.name,
                    email: signer.email,
                    status: signer.status,
                    tipo: signer.status === 'signed' ? 'sign' : 'witness',
                })),
                created_at: documentoZapSign.created_at,
                file_url: documentoZapSign.original_file,
            };
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw error;
            }
            console.error('Erro ao criar contrato no ZapSign:', error);
            throw new BadRequestException('Erro ao criar contrato no ZapSign');
        }
    }

    async buscarDocumentoZapSign(documentoId: string): Promise<RespostaContratoZapSignDto> {
        try {
            const documento = await this.zapSignService.getDocument(documentoId);

            return {
                id: documento.token,
                nome_documento: documento.name,
                status: documento.status,
                url_assinatura: documento.signers.find((s) => s.status === 'new')?.sign_url || undefined,
                signers: documento.signers.map((signer) => ({
                    nome: signer.name,
                    email: signer.email,
                    status: signer.status,
                    tipo: signer.status === 'signed' ? 'sign' : 'witness',
                })),
                created_at: documento.created_at,
                file_url: documento.original_file,
            };
        } catch (error) {
            console.error('Erro ao buscar documento do ZapSign:', error);
            throw new BadRequestException('Erro ao buscar documento do ZapSign');
        }
    }

    async listarDocumentosZapSign() {
        try {
            return await this.zapSignService.getDocuments();
        } catch (error) {
            console.error('Erro ao listar documentos do ZapSign:', error);
            throw new BadRequestException('Erro ao listar documentos do ZapSign');
        }
    }

    async cancelarDocumentoZapSign(contratoId: string) {
        try {
            console.log('=== INICIANDO SOFT DELETE DE CONTRATO ===');
            console.log('ID do contrato recebido:', contratoId);

            // Validar se o ID √© um n√∫mero v√°lido
            const contratoIdNum = parseInt(contratoId);
            if (isNaN(contratoIdNum)) {
                throw new BadRequestException('ID do contrato inv√°lido');
            }

            // Buscar o contrato no banco de dados
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoIdNum.toString() },
            });

            if (!contrato) {
                console.log('Contrato n√£o encontrado no banco de dados');
                throw new BadRequestException('Contrato n√£o encontrado');
            }

            // Verificar se o contrato j√° foi deletado
            if (contrato.deletado_em) {
                console.log('Contrato j√° foi deletado anteriormente');
                throw new BadRequestException('Este contrato j√° foi removido anteriormente');
            }

            console.log('Contrato encontrado:', {
                id: contrato.id,
                temDadosContrato: !!contrato.dados_contrato,
                statusAssAluno: contrato.status_ass_aluno,
                jaDeletado: !!contrato.deletado_em,
            });

            // Tentar cancelar no ZapSign se o contrato foi criado l√°
            let resultadoZapSign = null;
            if (contrato.dados_contrato) {
                console.log('=== TENTANDO CANCELAR NO ZAPSIGN ===');

                // Extrair o ID do ZapSign dos dados do contrato
                const idDocumentoZapSign = contrato.dados_contrato?.contrato?.id_documento_zapsign;
                const idDocumentoZapSignAlt1 = contrato.dados_contrato?.id_documento_zapsign;
                const idDocumentoZapSignAlt2 = contrato.dados_contrato?.documento_final?.id_zapsign;

                const idFinal = idDocumentoZapSign || idDocumentoZapSignAlt1 || idDocumentoZapSignAlt2;
                console.log('ID do documento ZapSign encontrado:', idFinal);

                if (idFinal) {
                    try {
                        console.log('Cancelando documento no ZapSign com ID:', idFinal);
                        resultadoZapSign = await this.zapSignService.cancelDocument(idFinal);
                        console.log('Documento cancelado no ZapSign com sucesso');
                    } catch (error) {
                        console.log('Erro ao cancelar no ZapSign (continuando com soft delete):', error instanceof Error ? error.message : 'Erro desconhecido');
                        // N√£o falha o processo se n√£o conseguir cancelar no ZapSign
                    }
                } else {
                    console.log('ID do ZapSign n√£o encontrado - apenas soft delete ser√° realizado');
                }
            } else {
                console.log('Contrato n√£o possui dados_contrato - apenas soft delete ser√° realizado');
            }

            // Realizar soft delete no banco de dados
            console.log('=== REALIZANDO SOFT DELETE ===');
            contrato.deletado_em = new Date();
            contrato.atualizado_em = new Date();

            await this.uow.turmasAlunosTreinamentosContratosRP.save(contrato);

            console.log('Soft delete realizado com sucesso');
            console.log('Data de dele√ß√£o:', contrato.deletado_em);

            return {
                message: 'Contrato removido com sucesso',
                deletado_em: contrato.deletado_em,
                zapSign_cancelado: !!resultadoZapSign,
                zapSign_resultado: resultadoZapSign,
            };
        } catch (error) {
            console.error('=== ERRO NO SOFT DELETE ===');
            console.error('Erro ao realizar soft delete do contrato:', error);
            // Se j√° √© um BadRequestException, relan√ßar sem modificar
            if (error instanceof BadRequestException) {
                throw error;
            }
            // Para outros erros, criar uma nova exce√ß√£o
            throw new BadRequestException('Erro ao remover contrato');
        }
    }

    async enviarLembreteAssinatura(contratoId: string) {
        try {
            console.log('=== INICIANDO ENVIO DE LEMBRETE ===');
            console.log('ID do contrato recebido:', contratoId);

            // Validar se o ID √© um n√∫mero v√°lido
            const contratoIdNum = parseInt(contratoId);
            if (isNaN(contratoIdNum)) {
                throw new BadRequestException('ID do contrato inv√°lido');
            }

            // Buscar o contrato no banco de dados
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoIdNum.toString() },
            });

            if (!contrato) {
                console.log('Contrato n√£o encontrado no banco de dados');
                throw new BadRequestException('Contrato n√£o encontrado');
            }

            console.log('Contrato encontrado:', {
                id: contrato.id,
                temDadosContrato: !!contrato.dados_contrato,
                statusAssAluno: contrato.status_ass_aluno,
            });

            // Verificar se o contrato tem dados_contrato
            if (!contrato.dados_contrato) {
                console.log('Contrato n√£o possui dados_contrato');
                throw new BadRequestException('Este contrato n√£o possui dados completos. N√£o √© poss√≠vel enviar lembrete no ZapSign.');
            }

            // Extrair o ID do ZapSign dos dados do contrato
            console.log('=== BUSCANDO ID DO ZAPSIGN ===');
            console.log('Estrutura dos dados_contrato:', JSON.stringify(contrato.dados_contrato, null, 2));

            // Tentar diferentes caminhos para encontrar o ID do ZapSign
            const idDocumentoZapSign = contrato.dados_contrato?.contrato?.id_documento_zapsign;
            const idDocumentoZapSignAlt1 = contrato.dados_contrato?.id_documento_zapsign;
            const idDocumentoZapSignAlt2 = contrato.dados_contrato?.documento_final?.id_zapsign;

            console.log('ID do documento ZapSign (caminho 1):', idDocumentoZapSign);
            console.log('ID do documento ZapSign (caminho 2):', idDocumentoZapSignAlt1);
            console.log('ID do documento ZapSign (caminho 3):', idDocumentoZapSignAlt2);

            const idFinal = idDocumentoZapSign || idDocumentoZapSignAlt1 || idDocumentoZapSignAlt2;
            console.log('ID final escolhido:', idFinal);

            if (!idFinal) {
                console.log('=== FALLBACK: BUSCANDO POR NOME ===');
                // Fallback: tentar encontrar o documento pelo nome
                try {
                    const documentos = await this.zapSignService.getDocuments();
                    console.log('Documentos encontrados no ZapSign:', documentos.length);

                    const nomeDocumento = contrato.dados_contrato?.documento_final?.nome;
                    const nomeAluno = contrato.dados_contrato?.aluno?.nome;

                    console.log('Procurando documento com nome:', nomeDocumento);
                    console.log('Nome do aluno:', nomeAluno);

                    const documentoEncontrado = documentos.find((doc) => {
                        const matchNome = doc.name === nomeDocumento;
                        const matchAluno = doc.name?.includes(nomeAluno);
                        console.log(`Documento "${doc.name}" - Match nome: ${matchNome}, Match aluno: ${matchAluno}`);
                        return matchNome || matchAluno;
                    });

                    if (documentoEncontrado) {
                        console.log('Documento encontrado no ZapSign:', documentoEncontrado.token);
                        return await this.zapSignService.sendReminder(documentoEncontrado.token);
                    } else {
                        console.log('Documento n√£o encontrado no ZapSign. Este contrato pode n√£o ter sido criado no ZapSign ou j√° foi cancelado.');
                        throw new BadRequestException('Documento n√£o encontrado no ZapSign. Este contrato pode n√£o ter sido criado no ZapSign ou j√° foi cancelado.');
                    }
                } catch (error) {
                    console.log('Erro ao buscar documentos no ZapSign:', error instanceof Error ? error.message : 'Erro desconhecido');
                    throw new BadRequestException('N√£o foi poss√≠vel enviar lembrete. Verifique se o contrato foi criado no ZapSign.');
                }
            }

            console.log('=== ENVIANDO LEMBRETE NO ZAPSIGN ===');
            console.log('ID do documento ZapSign:', idFinal);
            return await this.zapSignService.sendReminder(idFinal);
        } catch (error) {
            console.error('=== ERRO NO ENVIO DE LEMBRETE ===');
            console.error('Erro ao enviar lembrete:', error);
            // Se j√° √© um BadRequestException, relan√ßar sem modificar
            if (error instanceof BadRequestException) {
                throw error;
            }
            // Para outros erros, criar uma nova exce√ß√£o
            throw new BadRequestException('Erro ao enviar lembrete');
        }
    }

    private construirDocumentoDinamico(template: any, aluno: any, treinamento: any, turma: any, formasPagamento: any[], dadosContrato: any): string {
        // Construir o documento baseado no modelo fornecido
        let documento = this.construirEstruturaContrato(template, aluno, treinamento, turma, formasPagamento, dadosContrato);

        // Substituir campos din√¢micos baseados nos campos da tabela documentos
        if (template.campos && Array.isArray(template.campos)) {
            template.campos.forEach((campo: any) => {
                const placeholder = `{{${campo.campo}}}`;
                let valor = '';

                // Mapear campos espec√≠ficos baseados no nome do campo
                switch (campo.campo) {
                    case 'Nome Completo do Aluno':
                    case 'Nome Completo':
                        valor = aluno.nome;
                        break;
                    case 'Nome do Treinamento Contratado':
                        valor = treinamento.treinamento;
                        break;
                    case 'Email do Aluno':
                        valor = aluno.email;
                        break;
                    case 'CPF do Aluno':
                        valor = aluno.cpf;
                        break;
                    case 'Telefone do Aluno':
                        valor = aluno.telefone_um;
                        break;
                    case 'Pre√ßo do Treinamento':
                        valor = `R$ ${treinamento.preco_treinamento.toFixed(2).replace('.', ',')}`;
                        break;
                    case 'Forma de Pagamento':
                        valor = dadosContrato.forma_pagamento;
                        break;
                    case 'Data do Contrato':
                        valor = new Date().toLocaleDateString('pt-BR');
                        break;
                    case 'Local do Contrato':
                        valor = aluno.id_polo_fk?.nome || 'Local a definir';
                        break;
                    case 'Observa√ß√µes':
                        valor = dadosContrato.observacoes || '';
                        break;
                    default: {
                        // Tentar mapear automaticamente baseado em palavras-chave
                        const campoLower = campo.campo.toLowerCase();
                        if (campoLower.includes('nome') && campoLower.includes('aluno')) {
                            valor = aluno.nome;
                        } else if (campoLower.includes('treinamento')) {
                            valor = treinamento.treinamento;
                        } else if (campoLower.includes('email')) {
                            valor = aluno.email;
                        } else if (campoLower.includes('cpf')) {
                            valor = aluno.cpf;
                        } else if (campoLower.includes('telefone')) {
                            valor = aluno.telefone_um;
                        } else if (campoLower.includes('pre√ßo') || campoLower.includes('valor')) {
                            valor = `R$ ${treinamento.preco_treinamento.toFixed(2).replace('.', ',')}`;
                        } else if (campoLower.includes('data') && campoLower.includes('imers√£o') && campoLower.includes('prosperar')) {
                            valor = turma?.data_inicio ? new Date(turma.data_inicio).toLocaleDateString('pt-BR') : '___/___/___';
                        } else if (campoLower.includes('data')) {
                            valor = new Date().toLocaleDateString('pt-BR');
                        } else if (campoLower.includes('local')) {
                            valor = aluno.id_polo_fk?.nome || 'Local a definir';
                        } else if (campoLower.includes('quantidade') && campoLower.includes('inscri√ß√µes')) {
                            valor = dadosContrato.campos_variaveis?.['Quantidade de Inscri√ß√µes'] || '1';
                        } else {
                            // Verificar se √© um campo vari√°vel
                            if (dadosContrato.campos_variaveis && dadosContrato.campos_variaveis[campo.campo]) {
                                valor = dadosContrato.campos_variaveis[campo.campo];
                            } else {
                                valor = `[${campo.campo}]`;
                            }
                        }
                        break;
                    }
                }

                documento = documento.replace(new RegExp(placeholder, 'g'), valor);
            });
        }

        return documento;
    }

    private construirEstruturaContrato(template: any, aluno: any, treinamento: any, turma: any, formasPagamento: any[], dadosContrato: any): string {
        const dataAtual = new Date().toLocaleDateString('pt-BR');
        const localContrato = dadosContrato.campos_variaveis?.['Local de Assinatura do Contrato'] || aluno.id_polo_fk?.nome || 'Local a definir';
        const cidadeTreinamento = dadosContrato.campos_variaveis?.['Cidade do Treinamento'] || 'Local a definir';
        const dataInicioTreinamento = dadosContrato.campos_variaveis?.['Data Prevista do Treinamento'] || 'Data Prevista do Treinamento';
        const dataFimTreinamento = dadosContrato.campos_variaveis?.['Data Final do Treinamento'] || 'Data Final do Treinamento';

        // Construir informa√ß√µes de pagamento detalhadas
        const infoPagamento = this.construirInfoPagamentoDetalhada(dadosContrato, formasPagamento);

        // Construir informa√ß√µes de b√¥nus detalhadas
        const infoBonus = this.construirInfoBonusDetalhada(dadosContrato, turma);

        // Construir informa√ß√µes de testemunhas
        let infoTestemunhas = '';
        if (dadosContrato.testemunha_um_id || dadosContrato.testemunha_um_nome) {
            const testemunhaUm = dadosContrato.testemunha_um_nome || 'Testemunha 1';
            const cpfTestemunhaUm = dadosContrato.testemunha_um_cpf || 'CPF da testemunha';
            infoTestemunhas += `Testemunha 1:\nNome: ${testemunhaUm}\nCPF: ${cpfTestemunhaUm}\n\n`;
        }

        if (dadosContrato.testemunha_dois_id || dadosContrato.testemunha_dois_nome) {
            const testemunhaDois = dadosContrato.testemunha_dois_nome || 'Testemunha 2';
            const cpfTestemunhaDois = dadosContrato.testemunha_dois_cpf || 'CPF da testemunha';
            infoTestemunhas += `Testemunha 2:\nNome: ${testemunhaDois}\nCPF: ${cpfTestemunhaDois}\n\n`;
        }

        // Construir o documento no novo formato
        let documento = `
INSTITUTO ACADEMY MIND

O presente instrumento tem como objetivo realizar a inscri√ß√£o da pessoa abaixo nominada no seguinte treinamento:

1. Dados Pessoais

Nome completo: ${aluno.nome}

CPF: ${aluno.cpf}

WhatsApp: ${aluno.telefone_um}

E-mail: ${aluno.email}

Endere√ßo: ${aluno.logradouro || ''} ${aluno.numero || ''} ${aluno.complemento || ''} ${aluno.bairro || ''}

Cidade/Estado: ${aluno.cidade || ''}/${aluno.estado || ''}

CEP: ${aluno.cep || ''}
===================
2. Treinamento e B√¥nus

Treinamento: ${treinamento.treinamento}

Cidade: ${cidadeTreinamento}

Data prevista: ${dataInicioTreinamento} √† ${dataFimTreinamento}

Pre√ßo do contrato: ${this.calcularPrecoTotalContrato(dadosContrato)}

B√¥nus inclu√≠dos: ${infoBonus}
===============
3. Formas de Pagamento

${infoPagamento}

Local: ${localContrato}                    Data: ${dataAtual}

Declaro que li e concordo com todas as cl√°usulas deste contrato, redigidas em 2 laudas, estando ciente de todas elas, por meio da assinatura abaixo e na presen√ßa de 2 testemunhas.

Assinatura do ALUNO/Contratante:
_________________________________

${infoTestemunhas}
`;

        // Adicionar as cl√°usulas do template se existirem
        if (template.clausulas && template.clausulas.trim()) {
            documento += `\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
            documento += `CL√ÅUSULAS DO CONTRATO\n`;
            documento += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
            documento += template.clausulas;
        }

        return documento;
    }

    /**
     * Constr√≥i informa√ß√µes detalhadas de pagamento no formato solicitado
     */
    private construirInfoPagamentoDetalhada(dadosContrato: any, formasPagamento: any[]): string {
        const valoresFormas = dadosContrato.valores_formas_pagamento || {};
        let infoPagamento = '';

        if (dadosContrato.forma_pagamento === 'A_VISTA') {
            // Processar formas √† vista
            const formasVista = [];
            if (valoresFormas['√Ä Vista - Cart√£o de Cr√©dito']) {
                const valor = parseInt(valoresFormas['√Ä Vista - Cart√£o de Cr√©dito'].valor) / 100;
                formasVista.push(`‚òë Cart√£o de Cr√©dito - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
            }
            if (valoresFormas['√Ä Vista - Cart√£o de D√©bito']) {
                const valor = parseInt(valoresFormas['√Ä Vista - Cart√£o de D√©bito'].valor) / 100;
                formasVista.push(`‚òë Cart√£o de D√©bito - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
            }
            if (valoresFormas['√Ä Vista - PIX/Transfer√™ncia']) {
                const valor = parseInt(valoresFormas['√Ä Vista - PIX/Transfer√™ncia'].valor) / 100;
                formasVista.push(`‚òë PIX/Transfer√™ncia - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
            }
            if (valoresFormas['√Ä Vista - Esp√©cie']) {
                const valor = parseInt(valoresFormas['√Ä Vista - Esp√©cie'].valor) / 100;
                formasVista.push(`‚òë Esp√©cie - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
            }

            infoPagamento = `√Ä vista: ${formasVista.join(', ')}`;
        } else if (dadosContrato.forma_pagamento === 'PARCELADO') {
            // Processar formas parceladas
            const formasParceladas = [];
            if (valoresFormas['Parcelado - Cart√£o de Cr√©dito']) {
                const dados = valoresFormas['Parcelado - Cart√£o de Cr√©dito'];
                const valor = parseInt(dados.valor || dados.valor_parcelas) / 100; // Valor total - usar valor_parcelas se valor n√£o existir
                const numeroParcelas = parseInt(dados.numero_parcelas);
                const valorParcela = valor / numeroParcelas;
                formasParceladas.push(
                    `‚òë Cart√£o de Cr√©dito - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })} - Em ${numeroParcelas}x de ${valorParcela.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`,
                );
            }

            // Processar boleto com chave longa
            const chaveBoletoLonga = 'Parcelado - Boleto:  Parcelas de: . Melhor dia de Vencimento: . Data para o 1¬∫ Boleto: .';
            if (valoresFormas[chaveBoletoLonga]) {
                const dados = valoresFormas[chaveBoletoLonga];
                const valor = parseInt(dados.valor || dados.valor_parcelas) / 100; // Valor total - usar valor_parcelas se valor n√£o existir
                const numeroParcelas = parseInt(dados.numero_parcelas);
                const valorParcela = valor / numeroParcelas;
                const melhorDia = dados.melhor_dia_vencimento || '1';
                const primeiroBoleto = dados.data_primeiro_boleto || 'data do primeiro boleto';
                formasParceladas.push(
                    `‚òë Boleto - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })} (${numeroParcelas}x de ${valorParcela.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}) Primeiro boleto: ${primeiroBoleto}, Melhor dia de vencimento: dia ${melhorDia} de cada m√™s`,
                );
            }

            infoPagamento = `Parcelado: ${formasParceladas.join(', ')}`;
        } else if (dadosContrato.forma_pagamento === 'AMBOS') {
            // Processar formas mistas
            const formasVista = [];
            const formasParceladas = [];

            // √Ä vista
            if (valoresFormas['√Ä Vista - Cart√£o de Cr√©dito']) {
                const valor = parseInt(valoresFormas['√Ä Vista - Cart√£o de Cr√©dito'].valor) / 100;
                formasVista.push(`‚òë Cart√£o de Cr√©dito - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
            }
            if (valoresFormas['√Ä Vista - Cart√£o de D√©bito']) {
                const valor = parseInt(valoresFormas['√Ä Vista - Cart√£o de D√©bito'].valor) / 100;
                formasVista.push(`‚òë Cart√£o de D√©bito - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
            }
            if (valoresFormas['√Ä Vista - PIX/Transfer√™ncia']) {
                const valor = parseInt(valoresFormas['√Ä Vista - PIX/Transfer√™ncia'].valor) / 100;
                formasVista.push(`‚òë PIX/Transfer√™ncia - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
            }
            if (valoresFormas['√Ä Vista - Esp√©cie']) {
                const valor = parseInt(valoresFormas['√Ä Vista - Esp√©cie'].valor) / 100;
                formasVista.push(`‚òë Esp√©cie - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
            }

            // Parcelado
            if (valoresFormas['Parcelado - Cart√£o de Cr√©dito']) {
                const dados = valoresFormas['Parcelado - Cart√£o de Cr√©dito'];
                const valor = parseInt(dados.valor || dados.valor_parcelas) / 100; // Valor total - usar valor_parcelas se valor n√£o existir
                const numeroParcelas = parseInt(dados.numero_parcelas);
                const valorParcela = valor / numeroParcelas;
                formasParceladas.push(
                    `‚òë Cart√£o de Cr√©dito - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })} - Em ${numeroParcelas}x de ${valorParcela.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`,
                );
            }

            // Processar boleto com chave longa
            const chaveBoletoLonga = 'Parcelado - Boleto:  Parcelas de: . Melhor dia de Vencimento: . Data para o 1¬∫ Boleto: .';
            if (valoresFormas[chaveBoletoLonga]) {
                const dados = valoresFormas[chaveBoletoLonga];
                const valor = parseInt(dados.valor || dados.valor_parcelas) / 100; // Valor total - usar valor_parcelas se valor n√£o existir
                const numeroParcelas = parseInt(dados.numero_parcelas);
                const valorParcela = valor / numeroParcelas;
                const melhorDia = dados.melhor_dia_vencimento || '1';
                const primeiroBoleto = dados.data_primeiro_boleto || 'data do primeiro boleto';
                formasParceladas.push(
                    `‚òë Boleto - ${valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })} (${numeroParcelas}x de ${valorParcela.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}) Primeiro boleto: ${primeiroBoleto}, Melhor dia de vencimento: dia ${melhorDia} de cada m√™s`,
                );
            }

            const partes = [];
            if (formasVista.length > 0) {
                partes.push(`√Ä vista: ${formasVista.join(', ')}`);
            }
            if (formasParceladas.length > 0) {
                partes.push(`Parcelado: ${formasParceladas.join(', ')}`);
            }

            infoPagamento = partes.join('\n\n');
        }

        return infoPagamento;
    }

    /**
     * Constr√≥i informa√ß√µes detalhadas de b√¥nus no formato solicitado
     */
    private construirInfoBonusDetalhada(dadosContrato: any, turma: any): string {
        const tiposBonus = dadosContrato.tipos_bonus || [];
        const valoresBonus = dadosContrato.valores_bonus || {};
        const camposVariaveis = dadosContrato.campos_variaveis || {};
        const bonusAtivos = [];

        // Verificar quais b√¥nus est√£o ativos
        if (tiposBonus.includes('100_dias')) {
            bonusAtivos.push('‚òë 100 Dias');
        }

        if (tiposBonus.includes('ipr') && dadosContrato.id_turma_bonus && turma) {
            const quantidadeInscricoes = camposVariaveis['Quantidade de Inscri√ß√µes'] || camposVariaveis['Quantidade de Inscri√ß√µes do Prosperar'] || '1';
            const dataImersao = turma.data_inicio ? new Date(turma.data_inicio).toLocaleDateString('pt-BR') : '09/10/2025';
            bonusAtivos.push(`‚òë ${quantidadeInscricoes} - Inscri√ß√£o Imers√£o Prosperar ‚Äì Data: ${dataImersao}`);
        }

        if (valoresBonus['B√¥nus-Outros: {{Descri√ß√£o do Outro B√¥nus}}'] && camposVariaveis['Descri√ß√£o do Outro B√¥nus']) {
            const descricaoOutros = camposVariaveis['Descri√ß√£o do Outro B√¥nus'];
            bonusAtivos.push(`‚òë Outros: ${descricaoOutros}`);
        }

        // Se n√£o h√° b√¥nus ativos, mostrar "N√£o se aplica"
        if (bonusAtivos.length === 0) {
            return '‚òë N√£o se aplica';
        }

        return bonusAtivos.join('\n');
    }

    /**
     * Calcula o pre√ßo total do contrato somando todas as formas de pagamento
     */
    private calcularPrecoTotalContrato(dadosContrato: any): string {
        const valoresFormas = dadosContrato.valores_formas_pagamento || {};
        let total = 0;

        // Somar todos os valores das formas de pagamento
        Object.values(valoresFormas).forEach((dados: any) => {
            if (dados.valor) {
                const valor = typeof dados.valor === 'string' ? parseInt(dados.valor) : dados.valor;
                total += valor / 100; // Converter de centavos para reais
            }
        });

        return total.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
    }

    /**
     * Enriquece os dados de formas de pagamento com campos calculados
     */
    private enriquecerValoresFormasPagamento(valoresFormas: Record<string, any>): Record<string, any> {
        const valoresEnriquecidos = { ...valoresFormas };

        // Processar boleto parcelado
        if (valoresFormas['Parcelado - Boleto']) {
            const dadosBoleto = valoresFormas['Parcelado - Boleto'];
            const valorTotalCentavos = parseInt(dadosBoleto.valor); // Valor total em centavos
            const valorTotalReais = valorTotalCentavos / 100; // Converter para reais
            const numeroParcelas = parseInt(dadosBoleto.numero_parcelas);
            const valorParcelaReais = valorTotalReais / numeroParcelas;

            valoresEnriquecidos['Parcelado - Boleto'] = {
                ...dadosBoleto,
                valor_parcelas: valorParcelaReais.toFixed(2), // Valor por parcela em reais com 2 casas decimais
            };
        }

        // Processar boleto com chave longa (formato antigo)
        const chaveBoletoLonga = 'Parcelado - Boleto:  Parcelas de: . Melhor dia de Vencimento: . Data para o 1¬∫ Boleto: .';
        if (valoresFormas[chaveBoletoLonga]) {
            const dadosBoleto = valoresFormas[chaveBoletoLonga];
            const valorTotalCentavos = parseInt(dadosBoleto.valor_parcelas); // Valor total em centavos
            const valorTotalReais = valorTotalCentavos / 100; // Converter para reais
            const numeroParcelas = parseInt(dadosBoleto.numero_parcelas);
            const valorParcelaReais = valorTotalReais / numeroParcelas;

            valoresEnriquecidos[chaveBoletoLonga] = {
                ...dadosBoleto,
                valor: valorTotalCentavos.toString(), // Valor total em centavos
                valor_parcelas: valorParcelaReais.toFixed(2), // Valor por parcela em reais com 2 casas decimais
            };
        }

        // Processar cart√£o de cr√©dito parcelado
        if (valoresFormas['Parcelado - Cart√£o de Cr√©dito']) {
            const dadosCartao = valoresFormas['Parcelado - Cart√£o de Cr√©dito'];
            const valorTotalCentavos = parseInt(dadosCartao.valor); // Valor total em centavos
            const valorTotalReais = valorTotalCentavos / 100; // Converter para reais
            const numeroParcelas = parseInt(dadosCartao.numero_parcelas);
            const valorParcelaReais = valorTotalReais / numeroParcelas;

            valoresEnriquecidos['Parcelado - Cart√£o de Cr√©dito'] = {
                ...dadosCartao,
                valor_parcelas: valorParcelaReais.toFixed(2), // Valor por parcela em reais com 2 casas decimais
            };
        }

        return valoresEnriquecidos;
    }

    /**
     * Compila todos os dados do contrato em um objeto estruturado para armazenamento
     */
    private compilarDadosContrato(
        criarContratoDto: CriarContratoZapSignDto,
        aluno: any,
        treinamento: any,
        turma: any,
        formasPagamento: any[],
        template: any,
        documentoConteudo: string,
    ): any {
        const dataAtual = new Date();

        return {
            // Informa√ß√µes b√°sicas do contrato
            contrato: {
                id_documento_zapsign: null, // Ser√° preenchido ap√≥s cria√ß√£o no ZapSign
                template_id: criarContratoDto.template_id,
                data_criacao: dataAtual.toISOString(),
                data_criacao_brasil: dataAtual.toLocaleDateString('pt-BR'),
                observacoes: criarContratoDto.observacoes || null,
                status: 'PENDENTE_ASSINATURA',
            },

            // Dados do aluno
            aluno: {
                id: aluno.id,
                nome: aluno.nome,
                email: aluno.email,
                cpf: aluno.cpf,
                telefone_um: aluno.telefone_um,
                telefone_dois: aluno.telefone_dois || null,
                data_nascimento: aluno.data_nascimento || null,
                endereco: {
                    logradouro: aluno.logradouro || null,
                    numero: aluno.numero || null,
                    complemento: aluno.complemento || null,
                    bairro: aluno.bairro || null,
                    cidade: aluno.cidade || null,
                    estado: aluno.estado || null,
                    cep: aluno.cep || null,
                },
                polo: {
                    id: aluno.id_polo_fk?.id || null,
                    nome: aluno.id_polo_fk?.nome || null,
                    cidade: aluno.id_polo_fk?.cidade || null,
                    estado: aluno.id_polo_fk?.estado || null,
                },
            },

            // Dados do treinamento
            treinamento: {
                id: treinamento.id,
                nome: treinamento.treinamento,
                sigla: treinamento.sigla_treinamento || null,
                preco: treinamento.preco_treinamento,
                descricao: treinamento.descricao || null,
                carga_horaria: treinamento.carga_horaria || null,
                modalidade: treinamento.modalidade || null,
                url_logo_treinamento: treinamento.url_logo_treinamento || null,
            },

            // Dados da turma b√¥nus (IPR)
            turma_bonus: turma
                ? {
                      id: turma.id,
                      turma: turma.turma,
                      edicao_turma: turma.edicao_turma || null,
                      data_inicio: turma.data_inicio,
                      data_fim: turma.data_final,
                      status_turma: turma.status_turma,
                      cidade: turma.cidade,
                      estado: turma.estado,
                      lider_evento: turma.lider_evento_fk
                          ? {
                                id: turma.lider_evento_fk.id,
                                nome: turma.lider_evento_fk.nome,
                                email: turma.lider_evento_fk.email,
                            }
                          : null,
                  }
                : null,

            // Formas de pagamento
            pagamento: {
                forma_pagamento: criarContratoDto.forma_pagamento,
                formas_pagamento: formasPagamento.map((fp) => ({
                    tipo: fp.tipo,
                    forma: fp.forma,
                    valor: fp.valor,
                    descricao: fp.descricao || null,
                })),
                valores_formas_pagamento: this.enriquecerValoresFormasPagamento(criarContratoDto.valores_formas_pagamento || {}),
            },

            // B√¥nus e campos vari√°veis
            bonus: {
                tipos_bonus: criarContratoDto.tipos_bonus || [],
                valores_bonus: criarContratoDto.valores_bonus || {},
                id_turma_bonus: criarContratoDto.id_turma_bonus || null,
                turma_bonus_info: turma
                    ? {
                          id: turma.id,
                          turma: turma.turma,
                          edicao_turma: turma.edicao_turma || null,
                          data_inicio: turma.data_inicio,
                          data_fim: turma.data_final,
                          status_turma: turma.status_turma,
                          cidade: turma.cidade,
                          estado: turma.estado,
                      }
                    : null,
            },

            // Campos vari√°veis do contrato
            campos_variaveis: criarContratoDto.campos_variaveis || {},

            // Testemunhas
            testemunhas: {
                testemunha_um: {
                    tipo: criarContratoDto.testemunha_um_id ? 'banco' : 'manual',
                    id: criarContratoDto.testemunha_um_id || null,
                    nome: criarContratoDto.testemunha_um_nome || null,
                    cpf: criarContratoDto.testemunha_um_cpf || null,
                    email: null, // Ser√° preenchido se for do banco
                    telefone: null, // Ser√° preenchido se for do banco
                },
                testemunha_dois: {
                    tipo: criarContratoDto.testemunha_dois_id ? 'banco' : 'manual',
                    id: criarContratoDto.testemunha_dois_id || null,
                    nome: criarContratoDto.testemunha_dois_nome || null,
                    cpf: criarContratoDto.testemunha_dois_cpf || null,
                    email: null, // Ser√° preenchido se for do banco
                    telefone: null, // Ser√° preenchido se for do banco
                },
            },

            // Template utilizado
            template: {
                id: template.id,
                nome: template.documento,
                tipo_documento: template.tipo_documento,
                campos_disponiveis: template.campos || [],
                clausulas: template.clausulas || null,
            },

            // Documento final gerado
            documento_final: {
                nome: `Contrato ${treinamento.treinamento} - ${aluno.nome} - ${dataAtual.toLocaleDateString('pt-BR')}`,
                conteudo: documentoConteudo,
                data_geracao: dataAtual.toISOString(),
            },

            // Metadados do sistema
            metadata: {
                versao_dados_contrato: '1.0',
                criado_por: null, // Ser√° preenchido pelo userId
                data_compilacao: dataAtual.toISOString(),
                origem: 'CRIACAO_CONTRATO_ZAPSIGN',
            },
        };
    }

    /**
     * Busca um contrato espec√≠fico com todos os dados armazenados
     */
    async buscarContratoCompleto(contratoId: string): Promise<any> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId, deletado_em: null },
                relations: ['id_turma_aluno_treinamento_fk', 'id_documento_fk', 'testemunha_um_fk', 'testemunha_dois_fk'],
            });

            if (!contrato) {
                throw new NotFoundException('Contrato n√£o encontrado');
            }

            // Debug: Verificar assinaturas no contrato completo
            console.log('üîç Debug - Contrato completo encontrado:', {
                id: contrato.id,
                assinatura_aluno: !!contrato.assinatura_aluno_base64,
                assinatura_testemunha_um: !!contrato.assinatura_testemunha_um_base64,
                assinatura_testemunha_dois: !!contrato.assinatura_testemunha_dois_base64,
                status_ass_aluno: contrato.status_ass_aluno,
                status_ass_test_um: contrato.status_ass_test_um,
                status_ass_test_dois: contrato.status_ass_test_dois,
            });

            return {
                id: contrato.id,
                status_ass_aluno: contrato.status_ass_aluno,
                data_ass_aluno: contrato.data_ass_aluno,
                status_ass_test_um: contrato.status_ass_test_um,
                data_ass_test_um: contrato.data_ass_test_um,
                status_ass_test_dois: contrato.status_ass_test_dois,
                data_ass_test_dois: contrato.data_ass_test_dois,
                // Assinaturas
                assinatura_aluno_base64: contrato.assinatura_aluno_base64,
                tipo_assinatura_aluno: contrato.tipo_assinatura_aluno,
                foto_documento_aluno_base64: contrato.foto_documento_aluno_base64,
                assinatura_testemunha_um_base64: contrato.assinatura_testemunha_um_base64,
                tipo_assinatura_testemunha_um: contrato.tipo_assinatura_testemunha_um,
                assinatura_testemunha_dois_base64: contrato.assinatura_testemunha_dois_base64,
                tipo_assinatura_testemunha_dois: contrato.tipo_assinatura_testemunha_dois,
                // Assinatura eletr√¥nica
                assinatura_eletronica: contrato.assinatura_eletronica,
                // Dados ZapSign
                zapsign_document_id: contrato.zapsign_document_id,
                zapsign_signers_data: contrato.zapsign_signers_data,
                zapsign_document_status: contrato.zapsign_document_status,
                dados_contrato: {
                    ...contrato.dados_contrato,
                    contrato: {
                        ...contrato.dados_contrato?.contrato,
                        url_assinatura: contrato.dados_contrato?.contrato?.id_documento_zapsign
                            ? `https://zapsign.com.br/assinatura/${contrato.dados_contrato.contrato.id_documento_zapsign}`
                            : null,
                        file_url: contrato.dados_contrato?.contrato?.file_url || null,
                    },
                },
                aluno_nome: contrato.dados_contrato?.aluno?.nome || 'N/A',
                treinamento_nome: contrato.dados_contrato?.treinamento?.nome || 'N/A',
                testemunhas: {
                    testemunha_um: contrato.testemunha_um_fk
                        ? {
                              id: contrato.testemunha_um_fk.id,
                              nome: contrato.testemunha_um_fk.nome,
                              email: contrato.testemunha_um_fk.email,
                          }
                        : null,
                    testemunha_dois: contrato.testemunha_dois_fk
                        ? {
                              id: contrato.testemunha_dois_fk.id,
                              nome: contrato.testemunha_dois_fk.nome,
                              email: contrato.testemunha_dois_fk.email,
                          }
                        : null,
                },
                documento: contrato.id_documento_fk
                    ? {
                          id: contrato.id_documento_fk.id,
                          nome: contrato.id_documento_fk.documento,
                          tipo: contrato.id_documento_fk.tipo_documento,
                      }
                    : null,
                turma_aluno_treinamento: contrato.id_turma_aluno_treinamento_fk,
                created_at: contrato.criado_em,
                updated_at: contrato.atualizado_em,
            };
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw error;
            }
            console.error('Erro ao buscar contrato completo:', error);
            throw new BadRequestException('Erro ao buscar contrato completo');
        }
    }

    /**
     * Lista contratos com filtros opcionais
     */
    async listarContratos(filtros?: {
        id_aluno?: string;
        id_treinamento?: string;
        status?: string;
        data_inicio?: string;
        data_fim?: string;
        page?: number;
        limit?: number;
    }): Promise<any> {
        try {
            // Usar find com select expl√≠cito para garantir que todos os campos sejam carregados
            const contratos = await this.uow.turmasAlunosTreinamentosContratosRP.find({
                where: { deletado_em: null },
                relations: ['id_turma_aluno_treinamento_fk', 'id_documento_fk', 'testemunha_um_fk', 'testemunha_dois_fk'],
                select: {
                    id: true,
                    dados_contrato: true,
                    status_ass_aluno: true,
                    status_ass_test_um: true,
                    status_ass_test_dois: true,
                    data_ass_aluno: true,
                    data_ass_test_um: true,
                    data_ass_test_dois: true,
                    criado_em: true,
                    // Campos de assinatura
                    assinatura_aluno_base64: true,
                    tipo_assinatura_aluno: true,
                    foto_documento_aluno_base64: true,
                    assinatura_testemunha_um_base64: true,
                    tipo_assinatura_testemunha_um: true,
                    assinatura_testemunha_dois_base64: true,
                    tipo_assinatura_testemunha_dois: true,
                    // Assinatura eletr√¥nica
                    assinatura_eletronica: true,
                    // Dados ZapSign
                    zapsign_document_id: true,
                    zapsign_signers_data: true,
                    zapsign_document_status: true,
                },
                order: { criado_em: 'DESC' },
                take: filtros?.limit || 10,
                skip: filtros?.page ? (filtros.page - 1) * (filtros.limit || 10) : 0,
            });

            const total = await this.uow.turmasAlunosTreinamentosContratosRP.count({
                where: { deletado_em: null },
            });

            // Filtrar resultados se necess√°rio (implementa√ß√£o simplificada)
            let contratosFiltrados = contratos;

            if (filtros?.id_aluno) {
                contratosFiltrados = contratosFiltrados.filter((contrato) => contrato.dados_contrato?.aluno?.id === filtros.id_aluno);
            }

            if (filtros?.id_treinamento) {
                contratosFiltrados = contratosFiltrados.filter((contrato) => contrato.dados_contrato?.treinamento?.id === filtros.id_treinamento);
            }

            // Debug: Verificar se as assinaturas est√£o sendo retornadas
            console.log('üîç Debug - Contratos encontrados:', contratosFiltrados.length);
            if (contratosFiltrados.length > 0) {
                console.log('üîç Debug - Primeiro contrato assinaturas:', {
                    id: contratosFiltrados[0].id,
                    assinatura_aluno: !!contratosFiltrados[0].assinatura_aluno_base64,
                    assinatura_testemunha_um: !!contratosFiltrados[0].assinatura_testemunha_um_base64,
                    assinatura_testemunha_dois: !!contratosFiltrados[0].assinatura_testemunha_dois_base64,
                    status_ass_aluno: contratosFiltrados[0].status_ass_aluno,
                    status_ass_test_um: contratosFiltrados[0].status_ass_test_um,
                    status_ass_test_dois: contratosFiltrados[0].status_ass_test_dois,
                });

                // Debug: Verificar se os campos existem no objeto
                console.log('üîç Debug - Campos dispon√≠veis no contrato:', Object.keys(contratosFiltrados[0]));
                console.log('üîç Debug - Assinatura testemunha 2 raw:', contratosFiltrados[0].assinatura_testemunha_dois_base64 ? 'EXISTS' : 'NULL');
            }

            return {
                data: contratosFiltrados.map((contrato) => ({
                    id: contrato.id,
                    dados_contrato: contrato.dados_contrato,
                    status_ass_aluno: contrato.status_ass_aluno,
                    status_ass_test_um: contrato.status_ass_test_um,
                    status_ass_test_dois: contrato.status_ass_test_dois,
                    data_ass_aluno: contrato.data_ass_aluno,
                    data_ass_test_um: contrato.data_ass_test_um,
                    data_ass_test_dois: contrato.data_ass_test_dois,
                    created_at: contrato.criado_em,
                    aluno_nome: contrato.dados_contrato?.aluno?.nome || 'N/A',
                    treinamento_nome: contrato.dados_contrato?.treinamento?.nome || 'N/A',
                    // Assinaturas
                    assinatura_aluno_base64: contrato.assinatura_aluno_base64,
                    tipo_assinatura_aluno: contrato.tipo_assinatura_aluno,
                    foto_documento_aluno_base64: contrato.foto_documento_aluno_base64,
                    assinatura_testemunha_um_base64: contrato.assinatura_testemunha_um_base64,
                    tipo_assinatura_testemunha_um: contrato.tipo_assinatura_testemunha_um,
                    assinatura_testemunha_dois_base64: contrato.assinatura_testemunha_dois_base64,
                    tipo_assinatura_testemunha_dois: contrato.tipo_assinatura_testemunha_dois,
                    // Assinatura eletr√¥nica
                    assinatura_eletronica: contrato.assinatura_eletronica,
                    // Dados ZapSign
                    zapsign_document_id: contrato.zapsign_document_id,
                    zapsign_signers_data: contrato.zapsign_signers_data,
                    zapsign_document_status: contrato.zapsign_document_status,
                })),
                total,
                page: filtros?.page || 1,
                limit: filtros?.limit || 10,
                totalPages: Math.ceil(total / (filtros?.limit || 10)),
            };
        } catch (error) {
            console.error('Erro ao listar contratos:', error);
            throw new BadRequestException('Erro ao listar contratos');
        }
    }

    async salvarAssinatura(signatureData: {
        contratoId: string;
        signer: 'aluno' | 'testemunha1' | 'testemunha2';
        signatureType: 'escrita' | 'nome';
        signatureData?: string | null;
        signatureName?: string | null;
        documentPhoto?: string | null;
        signedAt: string;
    }): Promise<void> {
        console.log(`üîç IN√çCIO do m√©todo salvarAssinatura para ${signatureData.signer}`);
        console.log(`üìã Dados recebidos:`, {
            contratoId: signatureData.contratoId,
            signer: signatureData.signer,
            signatureName: signatureData.signatureName,
            signatureType: signatureData.signatureType,
            temSignatureData: !!signatureData.signatureData,
        });

        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: signatureData.contratoId },
            });

            if (!contrato) {
                throw new NotFoundException('Contrato n√£o encontrado');
            }

            console.log(`üìÑ Contrato encontrado:`, {
                id: contrato.id,
                temZapSignDocumentId: !!contrato.zapsign_document_id,
                zapsignDocumentId: contrato.zapsign_document_id,
                statusAssinaturas: {
                    aluno: contrato.status_ass_aluno,
                    testemunha1: contrato.status_ass_test_um,
                    testemunha2: contrato.status_ass_test_dois,
                },
            });

            const updateData: Partial<TurmasAlunosTreinamentosContratos> = {};

            switch (signatureData.signer) {
                case 'aluno':
                    updateData.status_ass_aluno = EStatusAssinaturasContratos.ASSINADO;
                    updateData.data_ass_aluno = new Date(signatureData.signedAt);
                    updateData.tipo_assinatura_aluno = signatureData.signatureType;

                    if (signatureData.signatureData) {
                        updateData.assinatura_aluno_base64 = signatureData.signatureData;
                    }

                    if (signatureData.documentPhoto) {
                        updateData.foto_documento_aluno_base64 = signatureData.documentPhoto;
                    }
                    break;

                case 'testemunha1':
                    updateData.status_ass_test_um = EStatusAssinaturasContratos.ASSINADO;
                    updateData.data_ass_test_um = new Date(signatureData.signedAt);
                    updateData.tipo_assinatura_testemunha_um = signatureData.signatureType;

                    if (signatureData.signatureData) {
                        updateData.assinatura_testemunha_um_base64 = signatureData.signatureData;
                    }
                    break;

                case 'testemunha2':
                    updateData.status_ass_test_dois = EStatusAssinaturasContratos.ASSINADO;
                    updateData.data_ass_test_dois = new Date(signatureData.signedAt);
                    updateData.tipo_assinatura_testemunha_dois = signatureData.signatureType;

                    if (signatureData.signatureData) {
                        updateData.assinatura_testemunha_dois_base64 = signatureData.signatureData;
                    }
                    break;
            }

            await this.uow.turmasAlunosTreinamentosContratosRP.update({ id: signatureData.contratoId }, updateData);

            console.log(`Assinatura ${signatureData.signer} salva com sucesso para o contrato ${signatureData.contratoId}`);

            // Tentar sincronizar automaticamente com ZapSign ap√≥s salvar localmente
            console.log(`üîç Verificando se contrato tem zapsign_document_id:`, {
                contratoId: signatureData.contratoId,
                temZapSignDocumentId: !!contrato.zapsign_document_id,
                zapsignDocumentId: contrato.zapsign_document_id,
            });

            if (contrato.zapsign_document_id) {
                console.log(`üîÑ Tentando sincronizar assinatura ${signatureData.signer} com ZapSign automaticamente...`);
                console.log(`üìã ZapSign Document ID: ${contrato.zapsign_document_id}`);

                try {
                    // Aguardar um pouco para garantir que a assinatura foi salva no banco
                    console.log(`‚è≥ Aguardando 2 segundos antes da sincroniza√ß√£o...`);
                    await new Promise((resolve) => setTimeout(resolve, 2000));

                    // Tentar sincronizar com ZapSign
                    console.log(`üöÄ Iniciando sincroniza√ß√£o com ZapSign...`);
                    const resultado = await this.sincronizarAssinaturasComZapSign(signatureData.contratoId);
                    console.log(`‚úÖ Sincroniza√ß√£o autom√°tica com ZapSign conclu√≠da para ${signatureData.signer}:`, resultado);
                } catch (syncError) {
                    console.error(`‚ùå Erro na sincroniza√ß√£o autom√°tica com ZapSign:`, syncError);
                    console.error(`‚ùå Detalhes do erro:`, {
                        message: syncError instanceof Error ? syncError.message : 'Erro desconhecido',
                        stack: syncError instanceof Error ? syncError.stack : undefined,
                    });
                    console.log(`üìù Assinatura ${signatureData.signer} salva localmente. Use sincroniza√ß√£o manual se necess√°rio.`);
                    console.log(`üîó Documento ZapSign: ${contrato.zapsign_document_id}`);
                }
            } else {
                console.log(`‚ö†Ô∏è Contrato ${signatureData.contratoId} n√£o possui zapsign_document_id - assinatura salva apenas localmente`);
                console.log(`üí° Para sincronizar com ZapSign, primeiro crie um documento no ZapSign para este contrato`);
            }
        } catch (error) {
            console.error('Erro ao salvar assinatura:', error);
            throw new BadRequestException('Erro ao salvar assinatura');
        }
    }

    /**
     * Sincroniza uma assinatura espec√≠fica com o ZapSign mantendo a estrutura dos signers
     */
    private async sincronizarAssinaturaComZapSign(
        contratoId: string,
        signer: 'aluno' | 'testemunha1' | 'testemunha2',
        signatureData?: string | null,
    ): Promise<void> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato || !contrato.zapsign_document_id) {
                console.log('‚ö†Ô∏è Contrato n√£o possui documento no ZapSign para sincroniza√ß√£o');
                return;
            }

            // Buscar dados atuais do ZapSign
            const apiUrl = process.env.ZAPSIGN_API_URL || 'https://api.zapsign.com.br';
            const authResult = await this.autenticarZapSign();
            const accessToken = authResult.accessToken;

            // Buscar documento atual no ZapSign
            const response = await fetch(`${apiUrl}/api/v1/documents/${contrato.zapsign_document_id}`, {
                method: 'GET',
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                },
            });

            if (!response.ok) {
                throw new Error(`Erro ao buscar documento no ZapSign: ${response.statusText}`);
            }

            const documentData = await response.json();
            console.log('üìÑ Dados atuais do documento ZapSign:', documentData);

            // Mapear signer interno para signer do ZapSign
            let signerName = '';
            let signerEmail = '';

            switch (signer) {
                case 'aluno':
                    signerName = contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.nome || 'Aluno';
                    signerEmail = contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.email || '';
                    break;
                case 'testemunha1':
                    signerName = contrato.dados_contrato?.testemunhas?.testemunha_um?.nome || 'Testemunha 1';
                    signerEmail = contrato.dados_contrato?.testemunhas?.testemunha_um?.email || '';
                    break;
                case 'testemunha2':
                    signerName = contrato.dados_contrato?.testemunhas?.testemunha_dois?.nome || 'Testemunha 2';
                    signerEmail = contrato.dados_contrato?.testemunhas?.testemunha_dois?.email || '';
                    break;
            }

            // Encontrar o signer correspondente no ZapSign
            const zapSignSigner = documentData.signers?.find((s: any) => s.name === signerName);

            if (!zapSignSigner) {
                console.log(`‚ö†Ô∏è Signer ${signerName} n√£o encontrado no ZapSign`);
                return;
            }

            // Preparar dados para atualiza√ß√£o do signer no ZapSign
            const updatedSigner = {
                ...zapSignSigner,
                status: 'signed',
                signed_at: new Date().toISOString(),
                // Manter todos os outros campos originais
            };

            // Se temos dados da assinatura, enviar para o ZapSign
            if (signatureData) {
                console.log(`üìù Enviando assinatura ${signer} para ZapSign...`);

                // Tentar atualizar o documento no ZapSign com a nova assinatura
                try {
                    // Preparar dados para atualiza√ß√£o no ZapSign
                    const updateData = {
                        signers: documentData.signers.map((s: any) => (s.name === signerName ? updatedSigner : s)),
                        // Incluir dados da assinatura se a API do ZapSign suportar
                        signature_data: signatureData,
                        signature_type: 'base64_image', // ou outro tipo conforme a API
                    };

                    // Tentar fazer PUT/PATCH no documento do ZapSign
                    const updateResponse = await fetch(`${apiUrl}/api/v1/documents/${contrato.zapsign_document_id}`, {
                        method: 'PUT',
                        headers: {
                            Authorization: `Bearer ${accessToken}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(updateData),
                    });

                    if (updateResponse.ok) {
                        console.log(`‚úÖ Documento ${contrato.zapsign_document_id} atualizado no ZapSign com assinatura ${signer}`);

                        // Buscar dados atualizados do ZapSign
                        const updatedDocumentResponse = await fetch(`${apiUrl}/api/v1/documents/${contrato.zapsign_document_id}`, {
                            method: 'GET',
                            headers: {
                                Authorization: `Bearer ${accessToken}`,
                                'Content-Type': 'application/json',
                            },
                        });

                        if (updatedDocumentResponse.ok) {
                            const updatedDocumentData = await updatedDocumentResponse.json();

                            // Atualizar dados do ZapSign no banco com dados reais do ZapSign
                            await this.uow.turmasAlunosTreinamentosContratosRP.update(
                                { id: contratoId },
                                {
                                    zapsign_signers_data: updatedDocumentData.signers || documentData.signers,
                                    zapsign_document_status: {
                                        ...contrato.zapsign_document_status,
                                        signers: updatedDocumentData.signers || documentData.signers,
                                        lastSync: new Date().toISOString(),
                                        lastSignatureUpdate: new Date().toISOString(),
                                    },
                                },
                            );

                            console.log(`‚úÖ Dados do ZapSign atualizados no banco ap√≥s assinatura ${signer}`);
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è Falha ao atualizar documento no ZapSign: ${updateResponse.statusText}`);

                        // Fallback: atualizar apenas localmente
                        const updatedSigners = documentData.signers.map((s: any) => (s.name === signerName ? updatedSigner : s));

                        await this.uow.turmasAlunosTreinamentosContratosRP.update(
                            { id: contratoId },
                            {
                                zapsign_signers_data: updatedSigners,
                                zapsign_document_status: {
                                    ...contrato.zapsign_document_status,
                                    signers: updatedSigners,
                                    lastSync: new Date().toISOString(),
                                    syncError: `Falha ao atualizar no ZapSign: ${updateResponse.statusText}`,
                                },
                            },
                        );

                        console.log(`‚ö†Ô∏è Assinatura ${signer} atualizada apenas localmente devido a erro no ZapSign`);
                    }
                } catch (updateError) {
                    console.error(`‚ùå Erro ao atualizar documento no ZapSign:`, updateError);

                    // Fallback: atualizar apenas localmente
                    const updatedSigners = documentData.signers.map((s: any) => (s.name === signerName ? updatedSigner : s));

                    await this.uow.turmasAlunosTreinamentosContratosRP.update(
                        { id: contratoId },
                        {
                            zapsign_signers_data: updatedSigners,
                            zapsign_document_status: {
                                ...contrato.zapsign_document_status,
                                signers: updatedSigners,
                                lastSync: new Date().toISOString(),
                                syncError: `Erro na atualiza√ß√£o: ${updateError instanceof Error ? updateError.message : 'Erro desconhecido'}`,
                            },
                        },
                    );

                    console.log(`‚ö†Ô∏è Assinatura ${signer} atualizada apenas localmente devido a erro na comunica√ß√£o com ZapSign`);
                }
            } else {
                // Mesmo sem dados da assinatura, atualizar o status
                console.log(`üìù Atualizando status ${signer} no ZapSign...`);

                const updatedSigners = documentData.signers.map((s: any) => (s.name === signerName ? updatedSigner : s));

                await this.uow.turmasAlunosTreinamentosContratosRP.update(
                    { id: contratoId },
                    {
                        zapsign_signers_data: updatedSigners,
                        zapsign_document_status: {
                            ...contrato.zapsign_document_status,
                            signers: updatedSigners,
                            lastSync: new Date().toISOString(),
                        },
                    },
                );

                console.log(`‚úÖ Status ${signer} atualizado no ZapSign`);
            }
        } catch (error) {
            console.error('‚ùå Erro ao sincronizar assinatura com ZapSign:', error);
            throw error;
        }
    }

    /**
     * Gera uma assinatura eletr√¥nica √∫nica para o contrato
     */
    private generateElectronicSignature(contratoId: string, dadosContrato: any, timestamp: Date): string {
        try {
            // Criar um hash √∫nico baseado nos dados do contrato
            const contractData = {
                contratoId,
                alunoNome: dadosContrato?.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.nome || '',
                alunoCpf: dadosContrato?.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.cpf || '',
                treinamentoNome: dadosContrato?.id_turma_aluno_treinamento_fk?.id_treinamento_fk?.treinamento || '',
                timestamp: timestamp.toISOString(),
                secretKey: process.env.JWT_SECRET || 'default-secret',
            };

            // Converter para string e criar hash SHA-256
            const dataString = JSON.stringify(contractData);
            const hash = crypto.createHash('sha256').update(dataString).digest('hex');

            // Criar assinatura eletr√¥nica formatada
            const signature = `E-SIGN-${hash.substring(0, 16).toUpperCase()}-${timestamp.getTime()}`;

            console.log(`Assinatura eletr√¥nica gerada: ${signature}`);
            return signature;
        } catch (error) {
            console.error('Erro ao gerar assinatura eletr√¥nica:', error);
            throw new BadRequestException('Erro ao gerar assinatura eletr√¥nica');
        }
    }

    /**
     * Envia assinatura diretamente para o ZapSign via API
     */
    async enviarAssinaturaParaZapSign(contratoId: string, signer: 'aluno' | 'testemunha1' | 'testemunha2', signatureData: string): Promise<boolean> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato || !contrato.zapsign_document_id) {
                throw new NotFoundException('Contrato n√£o possui documento no ZapSign');
            }

            const apiUrl = process.env.ZAPSIGN_API_URL || 'https://api.zapsign.com.br';
            const authResult = await this.autenticarZapSign();
            const accessToken = authResult.accessToken;

            // Mapear signer interno para signer do ZapSign
            let signerName = '';
            let signerEmail = '';

            switch (signer) {
                case 'aluno':
                    signerName = contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.nome || 'Aluno';
                    signerEmail = contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.email || '';
                    break;
                case 'testemunha1':
                    signerName = contrato.dados_contrato?.testemunhas?.testemunha_um?.nome || 'Testemunha 1';
                    signerEmail = contrato.dados_contrato?.testemunhas?.testemunha_um?.email || '';
                    break;
                case 'testemunha2':
                    signerName = contrato.dados_contrato?.testemunhas?.testemunha_dois?.nome || 'Testemunha 2';
                    signerEmail = contrato.dados_contrato?.testemunhas?.testemunha_dois?.email || '';
                    break;
            }

            console.log(`üì§ Enviando assinatura ${signer} (${signerName}) para ZapSign...`);

            // Tentar diferentes endpoints da API do ZapSign para enviar assinatura
            const endpoints = [
                `${apiUrl}/api/v1/documents/${contrato.zapsign_document_id}/signatures`,
                `${apiUrl}/api/v1/documents/${contrato.zapsign_document_id}/signers/sign`,
                `${apiUrl}/api/v1/signatures`,
            ];

            for (const endpoint of endpoints) {
                try {
                    const payload = {
                        document_id: contrato.zapsign_document_id,
                        signer_name: signerName,
                        signer_email: signerEmail,
                        signature_data: signatureData,
                        signature_type: 'base64_image',
                        signed_at: new Date().toISOString(),
                    };

                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            Authorization: `Bearer ${accessToken}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload),
                    });

                    if (response.ok) {
                        console.log(`‚úÖ Assinatura ${signer} enviada com sucesso para ZapSign via ${endpoint}`);

                        // Atualizar status no banco local
                        await this.atualizarStatusAssinaturaLocal(contratoId, signer, 'ASSINADO');

                        return true;
                    } else {
                        console.warn(`‚ö†Ô∏è Falha no endpoint ${endpoint}: ${response.statusText}`);
                    }
                } catch (endpointError) {
                    console.warn(`‚ö†Ô∏è Erro no endpoint ${endpoint}:`, endpointError);
                }
            }

            // Se nenhum endpoint funcionou, tentar atualizar o documento diretamente
            console.log(`üîÑ Tentando atualizar documento diretamente...`);
            await this.sincronizarAssinaturaComZapSign(contratoId, signer, signatureData);

            return true;
        } catch (error) {
            console.error(`‚ùå Erro ao enviar assinatura ${signer} para ZapSign:`, error);
            throw error;
        }
    }

    /**
     * Atualiza status da assinatura no banco local
     */
    private async atualizarStatusAssinaturaLocal(contratoId: string, signer: 'aluno' | 'testemunha1' | 'testemunha2', status: string): Promise<void> {
        const updateData: any = {};

        switch (signer) {
            case 'aluno':
                updateData.status_ass_aluno = status;
                updateData.data_ass_aluno = new Date();
                break;
            case 'testemunha1':
                updateData.status_ass_test_um = status;
                updateData.data_ass_test_um = new Date();
                break;
            case 'testemunha2':
                updateData.status_ass_test_dois = status;
                updateData.data_ass_test_dois = new Date();
                break;
        }

        await this.uow.turmasAlunosTreinamentosContratosRP.update({ id: contratoId }, updateData);
        console.log(`‚úÖ Status ${signer} atualizado localmente para ${status}`);
    }

    /**
     * Sincroniza uma assinatura individual com o ZapSign (m√©todo p√∫blico)
     */
    async sincronizarAssinaturaIndividualZapSign(contratoId: string, signer: 'aluno' | 'testemunha1' | 'testemunha2', signatureData?: string): Promise<void> {
        await this.sincronizarAssinaturaComZapSign(contratoId, signer, signatureData);
    }

    /**
     * Sincroniza assinaturas do ZapSign com a aplica√ß√£o
     */
    async sincronizarAssinaturasZapSign(contratoId: string): Promise<void> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato) {
                throw new NotFoundException('Contrato n√£o encontrado');
            }

            // Verificar se h√° dados do ZapSign
            if (!contrato.zapsign_document_id) {
                console.log('‚ö†Ô∏è Contrato n√£o possui ID do ZapSign para sincroniza√ß√£o');
                return;
            }

            const apiUrl = process.env.ZAPSIGN_API_URL || 'https://api.zapsign.com.br';
            const authResult = await this.autenticarZapSign();
            const accessToken = authResult.accessToken;

            // Buscar status do documento no ZapSign
            const response = await fetch(`${apiUrl}/api/v1/documents/${contrato.zapsign_document_id}`, {
                method: 'GET',
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                },
            });

            if (!response.ok) {
                throw new Error(`Erro ao buscar documento no ZapSign: ${response.statusText}`);
            }

            const documentData = await response.json();
            console.log('üìÑ Dados do documento ZapSign:', documentData);

            // Atualizar status das assinaturas baseado no ZapSign
            const updateData: Partial<TurmasAlunosTreinamentosContratos> = {};

            // Verificar status do aluno
            const alunoSigner = documentData.signers?.find((s: any) => s.name === contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.nome);

            if (alunoSigner && alunoSigner.status === 'signed' && contrato.status_ass_aluno !== EStatusAssinaturasContratos.ASSINADO) {
                updateData.status_ass_aluno = EStatusAssinaturasContratos.ASSINADO;
                updateData.data_ass_aluno = new Date();
                console.log('‚úÖ Aluno assinado no ZapSign - atualizando status');
            }

            // Verificar status das testemunhas
            const testemunhas = contrato.dados_contrato?.testemunhas;

            if (testemunhas?.testemunha_um) {
                const testemunha1Signer = documentData.signers?.find((s: any) => s.name === testemunhas.testemunha_um.nome);

                if (testemunha1Signer && testemunha1Signer.status === 'signed' && contrato.status_ass_test_um !== EStatusAssinaturasContratos.ASSINADO) {
                    updateData.status_ass_test_um = EStatusAssinaturasContratos.ASSINADO;
                    updateData.data_ass_test_um = new Date();
                    console.log('‚úÖ Testemunha 1 assinada no ZapSign - atualizando status');
                }
            }

            if (testemunhas?.testemunha_dois) {
                const testemunha2Signer = documentData.signers?.find((s: any) => s.name === testemunhas.testemunha_dois.nome);

                if (testemunha2Signer && testemunha2Signer.status === 'signed' && contrato.status_ass_test_dois !== EStatusAssinaturasContratos.ASSINADO) {
                    updateData.status_ass_test_dois = EStatusAssinaturasContratos.ASSINADO;
                    updateData.data_ass_test_dois = new Date();
                    console.log('‚úÖ Testemunha 2 assinada no ZapSign - atualizando status');
                }
            }

            // Atualizar dados do ZapSign
            updateData.zapsign_document_status = documentData;

            // Aplicar atualiza√ß√µes se houver mudan√ßas
            if (Object.keys(updateData).length > 1) {
                // Mais que apenas zapsign_document_status
                await this.uow.turmasAlunosTreinamentosContratosRP.update({ id: contratoId }, updateData);
                console.log('üîÑ Assinaturas sincronizadas com sucesso');
            }
        } catch (error) {
            console.error('‚ùå Erro ao sincronizar assinaturas do ZapSign:', error);
            throw new BadRequestException('Erro ao sincronizar assinaturas do ZapSign');
        }
    }

    /**
     * Salva a assinatura eletr√¥nica no contrato
     */
    async salvarAssinaturaEletronica(contratoId: string): Promise<{ assinaturaEletronica: string; dataAssinatura: string }> {
        try {
            // Buscar o contrato com as rela√ß√µes corretas
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
                relations: [
                    'id_turma_aluno_treinamento_fk',
                    'id_turma_aluno_treinamento_fk.id_turma_aluno_fk',
                    'id_turma_aluno_treinamento_fk.id_turma_aluno_fk.id_aluno_fk',
                    'id_turma_aluno_treinamento_fk.id_treinamento_fk',
                ],
            });

            if (!contrato) {
                throw new NotFoundException('Contrato n√£o encontrado');
            }

            // Verificar se j√° tem assinatura eletr√¥nica
            if (contrato.assinatura_eletronica) {
                throw new BadRequestException('Contrato j√° possui assinatura eletr√¥nica');
            }

            // Gerar timestamp atual
            const timestamp = new Date();

            // Gerar assinatura eletr√¥nica
            const assinaturaEletronica = this.generateElectronicSignature(contratoId, contrato.dados_contrato, timestamp);

            // Atualizar o contrato com a assinatura eletr√¥nica
            await this.uow.turmasAlunosTreinamentosContratosRP.update(
                { id: contratoId },
                {
                    assinatura_eletronica: assinaturaEletronica,
                    data_ass_aluno: timestamp,
                    status_ass_aluno: EStatusAssinaturasContratos.ASSINADO,
                },
            );

            console.log(`Assinatura eletr√¥nica salva para o contrato ${contratoId}: ${assinaturaEletronica}`);

            return {
                assinaturaEletronica,
                dataAssinatura: timestamp.toISOString(),
            };
        } catch (error) {
            console.error('Erro ao salvar assinatura eletr√¥nica:', error);
            throw new BadRequestException('Erro ao salvar assinatura eletr√¥nica');
        }
    }

    /**
     * Valida uma assinatura eletr√¥nica
     */
    async validarAssinaturaEletronica(contratoId: string, assinaturaEletronica: string): Promise<boolean> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato || !contrato.assinatura_eletronica) {
                return false;
            }

            return contrato.assinatura_eletronica === assinaturaEletronica;
        } catch (error) {
            console.error('Erro ao validar assinatura eletr√¥nica:', error);
            return false;
        }
    }

    /**
     * Autentica no ZapSign e retorna o token de acesso
     */
    autenticarZapSign(): Promise<{ accessToken: string; expiresIn: number }> {
        try {
            const apiKey = process.env.ZAPSIGN_API_KEY;
            const organizationId = process.env.ZAPSIGN_ORGANIZATION_ID;

            if (!apiKey) {
                console.warn('‚ö†Ô∏è ZAPSIGN_API_KEY n√£o configurada. Usando modo de teste.');
                // Para desenvolvimento/teste, usar credenciais fict√≠cias
                return Promise.resolve({
                    accessToken: 'test-token-' + Date.now(),
                    expiresIn: 3600,
                });
            }

            console.log('‚úÖ Token do ZapSign encontrado. Usando autentica√ß√£o por API Key.');
            return Promise.resolve({
                accessToken: apiKey,
                expiresIn: 3600, // Token de API Key n√£o expira
            });
        } catch (error) {
            console.error('Erro ao autenticar no ZapSign:', error);
            throw new BadRequestException('Erro ao autenticar no ZapSign');
        }
    }

    /**
     * Envia documento para o ZapSign para assinatura
     */
    async enviarDocumentoZapSign(contratoId: string, accessToken: string, dadosContrato: any): Promise<{ documentId: string; signingUrl: string }> {
        try {
            const apiUrl = process.env.ZAPSIGN_API_URL || 'https://api.zapsign.com.br';

            // Buscar o contrato para obter dados completos
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
                relations: [
                    'id_turma_aluno_treinamento_fk',
                    'id_turma_aluno_treinamento_fk.id_turma_aluno_fk',
                    'id_turma_aluno_treinamento_fk.id_turma_aluno_fk.id_aluno_fk',
                    'id_turma_aluno_treinamento_fk.id_treinamento_fk',
                ],
            });

            if (!contrato) {
                throw new NotFoundException('Contrato n√£o encontrado');
            }

            // Preparar dados do documento para o ZapSign
            // Usar PDF do frontend se dispon√≠vel, sen√£o usar do banco
            const pdfBase64 = dadosContrato?.dados_contrato?.pdf_base64 || contrato.dados_contrato?.pdf_base64 || '';

            // Verificar se o PDF √© muito grande (>30MB) e comprimir se necess√°rio
            const pdfSizeMB = Buffer.from(pdfBase64, 'base64').length / (1024 * 1024);
            console.log(`üìÑ Tamanho do PDF: ${pdfSizeMB.toFixed(2)}MB`);

            if (pdfSizeMB > 30) {
                console.warn('‚ö†Ô∏è PDF muito grande, tentando comprimir...');
                // Tentar comprimir o PDF ao inv√©s de usar modo simulado
                try {
                    // Aqui voc√™ pode implementar compress√£o de PDF se necess√°rio
                    console.log('üì¶ PDF grande detectado, mas tentando enviar mesmo assim...');
                } catch (compressError) {
                    console.error('‚ùå Erro ao comprimir PDF:', compressError);
                    throw new Error('PDF_TOO_LARGE');
                }
            }

            // Preparar signat√°rios baseado no status das assinaturas
            const signers = [];

            // Aluno - sempre incluir
            signers.push({
                name: contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.nome || 'Aluno',
                email: contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.email || 'aluno@teste.local',
            });

            // Testemunha 1 - sempre incluir
            signers.push({
                name: contrato.dados_contrato?.testemunhas?.testemunha_um?.nome || 'Testemunha 1',
                email: contrato.dados_contrato?.testemunhas?.testemunha_um?.email || 'testemunha1@teste.local',
            });

            // Testemunha 2 - sempre incluir
            signers.push({
                name: contrato.dados_contrato?.testemunhas?.testemunha_dois?.nome || 'Testemunha 2',
                email: contrato.dados_contrato?.testemunhas?.testemunha_dois?.email || 'testemunha2@teste.local',
            });

            // Remover o prefixo data:application/pdf;filename=generated.pdf;base64, se existir
            let cleanPdfBase64 = pdfBase64;
            if (pdfBase64.startsWith('data:application/pdf')) {
                cleanPdfBase64 = pdfBase64.split(',')[1];
            }

            const documentData = {
                name: `Contrato de Treinamento - ${contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.nome || 'Aluno'} - ${contrato.id_turma_aluno_treinamento_fk?.id_treinamento_fk?.treinamento || 'Treinamento'}`,
                base64_pdf: cleanPdfBase64,
                signers: signers,
            };

            // Se for token de teste, simular resposta
            if (accessToken.startsWith('test-token-')) {
                console.log('üß™ Modo de teste: Simulando envio para ZapSign');

                const testDocumentId = 'test-doc-' + Date.now();
                const testSigningUrl = 'https://test.zapsign.com.br/sign/test-doc-' + Date.now();

                // Salvar dados de teste no banco tamb√©m
                const testZapSignData = {
                    documentId: testDocumentId,
                    signers: [
                        {
                            name: contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.nome || 'Aluno',
                            email: contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.email || '',
                            status: 'pending',
                            signing_url: testSigningUrl,
                        },
                    ],
                    signingUrl: testSigningUrl,
                    status: 'pending',
                    createdAt: new Date().toISOString(),
                };

                // Atualizar contrato com dados de teste do ZapSign
                console.log(`üîÑ Tentando salvar dados de teste no contrato ${contratoId}:`, {
                    zapsign_document_id: testZapSignData.documentId,
                    zapsign_signers_data: testZapSignData.signers,
                    zapsign_document_status: testZapSignData,
                });

                // Buscar o contrato atual para preservar outros dados
                const contratoAtualTeste = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                    where: { id: contratoId },
                });

                if (!contratoAtualTeste) {
                    throw new NotFoundException('Contrato n√£o encontrado para atualiza√ß√£o de teste');
                }

                // Preparar dados para atualiza√ß√£o, preservando dados existentes
                const dadosAtualizacaoTeste = {
                    zapsign_document_id: testZapSignData.documentId,
                    zapsign_signers_data: testZapSignData.signers,
                    zapsign_document_status: testZapSignData,
                    // Preservar outros campos importantes
                    dados_contrato: contratoAtualTeste.dados_contrato,
                    assinatura_eletronica: contratoAtualTeste.assinatura_eletronica,
                    data_ass_aluno: contratoAtualTeste.data_ass_aluno,
                    status_ass_aluno: contratoAtualTeste.status_ass_aluno,
                };

                const updateResult = await this.uow.turmasAlunosTreinamentosContratosRP.update({ id: contratoId }, dadosAtualizacaoTeste);

                console.log(`‚úÖ Resultado da atualiza√ß√£o:`, updateResult);
                console.log(`‚úÖ Dados de teste do ZapSign salvos no contrato ${contratoId}`);
                console.log(`‚úÖ zapsign_document_id de teste salvo: ${testZapSignData.documentId}`);

                return {
                    documentId: testDocumentId,
                    signingUrl: testSigningUrl,
                };
            }

            // ZapSign API com API Key
            const organizationId = process.env.ZAPSIGN_ORGANIZATION_ID;

            console.log(`üöÄ Enviando documento para ZapSign:`, {
                apiUrl: `${apiUrl}/api/v1/docs/`,
                documentName: documentData.name,
                signersCount: documentData.signers.length,
                pdfSizeMB: pdfSizeMB.toFixed(2),
                pdfBase64Length: cleanPdfBase64.length,
                signers: documentData.signers,
            });

            const response = await axios.post(
                `${apiUrl}/api/v1/docs/`,
                {
                    name: documentData.name,
                    base64_pdf: documentData.base64_pdf,
                    signers: documentData.signers,
                },
                {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                        'Content-Type': 'application/json',
                    },
                    timeout: 60000, // 60 segundos de timeout
                },
            );

            console.log(`Documento enviado para ZapSign com sucesso: ${(response.data as any).token}`);

            // Salvar dados do ZapSign no banco
            const zapsignData = {
                documentId: (response.data as any).token,
                signers: (response.data as any).signers || [],
                signingUrl: (response.data as any).signers?.[0]?.sign_url || '',
                status: (response.data as any).status,
                createdAt: (response.data as any).created_at,
            };

            // Atualizar contrato com dados do ZapSign
            console.log(`üîÑ Tentando salvar dados reais do ZapSign no contrato ${contratoId}:`, {
                zapsign_document_id: zapsignData.documentId,
                zapsign_signers_data: zapsignData.signers,
                zapsign_document_status: zapsignData,
            });

            // Buscar o contrato atual para preservar outros dados
            const contratoAtual = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contratoAtual) {
                throw new NotFoundException('Contrato n√£o encontrado para atualiza√ß√£o');
            }

            // Preparar dados para atualiza√ß√£o, preservando dados existentes
            const dadosAtualizacao = {
                zapsign_document_id: zapsignData.documentId,
                zapsign_signers_data: zapsignData.signers,
                zapsign_document_status: zapsignData,
                // Preservar outros campos importantes
                dados_contrato: contratoAtual.dados_contrato,
                assinatura_eletronica: contratoAtual.assinatura_eletronica,
                data_ass_aluno: contratoAtual.data_ass_aluno,
                status_ass_aluno: contratoAtual.status_ass_aluno,
            };

            const updateResult = await this.uow.turmasAlunosTreinamentosContratosRP.update({ id: contratoId }, dadosAtualizacao);

            console.log(`‚úÖ Resultado da atualiza√ß√£o:`, updateResult);
            console.log(`‚úÖ Dados do ZapSign salvos no contrato ${contratoId}`);
            console.log(`‚úÖ zapsign_document_id salvo: ${zapsignData.documentId}`);

            return {
                documentId: zapsignData.documentId,
                signingUrl: zapsignData.signingUrl || `https://app.zapsign.com.br/sign/${zapsignData.documentId}`,
            };
        } catch (error) {
            console.error('‚ùå Erro ao enviar documento para ZapSign:', error);
            console.error('‚ùå Detalhes do erro:', {
                message: (error as any).message,
                status: (error as any).response?.status,
                statusText: (error as any).response?.statusText,
                data: (error as any).response?.data,
                code: (error as any).code,
            });

            // Se for erro de PDF muito grande, usar modo simulado
            if ((error as any).message === 'PDF_TOO_LARGE') {
                console.warn('‚ö†Ô∏è PDF muito grande, usando modo simulado...');

                const simDocumentId = 'zapsign-sim-' + Date.now();
                const simSigningUrl = 'https://app.zapsign.com.br/sign/simulado-' + Date.now();

                // Buscar o contrato atual para preservar outros dados
                const contratoAtualSim = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                    where: { id: contratoId },
                });

                if (!contratoAtualSim) {
                    throw new NotFoundException('Contrato n√£o encontrado para atualiza√ß√£o simulada');
                }

                // Salvar dados simulados no banco
                const simZapSignData = {
                    documentId: simDocumentId,
                    signers: [
                        {
                            name: contratoAtualSim.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.nome || 'Aluno',
                            email: contratoAtualSim.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.email || '',
                            status: 'pending',
                            signing_url: simSigningUrl,
                        },
                    ],
                    signingUrl: simSigningUrl,
                    status: 'pending',
                    createdAt: new Date().toISOString(),
                };

                // Preparar dados para atualiza√ß√£o, preservando dados existentes
                const dadosAtualizacaoSim = {
                    zapsign_document_id: simZapSignData.documentId,
                    zapsign_signers_data: simZapSignData.signers,
                    zapsign_document_status: simZapSignData,
                    // Preservar outros campos importantes
                    dados_contrato: contratoAtualSim.dados_contrato,
                    assinatura_eletronica: contratoAtualSim.assinatura_eletronica,
                    data_ass_aluno: contratoAtualSim.data_ass_aluno,
                    status_ass_aluno: contratoAtualSim.status_ass_aluno,
                };

                // Atualizar contrato com dados simulados do ZapSign
                await this.uow.turmasAlunosTreinamentosContratosRP.update({ id: contratoId }, dadosAtualizacaoSim);

                console.log(`‚úÖ Dados simulados do ZapSign salvos no contrato ${contratoId}`);
                console.log(`‚úÖ zapsign_document_id simulado salvo: ${simZapSignData.documentId}`);

                return {
                    documentId: simDocumentId,
                    signingUrl: simSigningUrl,
                };
            }

            // Relan√ßar erro - n√£o usar modo simulado
            console.error('‚ùå Erro ao criar documento no ZapSign');
            throw new BadRequestException('Erro ao criar documento no ZapSign: ' + ((error as any).message || 'Erro desconhecido'));
        }
    }

    /**
     * Consulta o status de um documento no ZapSign
     */
    async consultarStatusZapSign(contratoId: string): Promise<any> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato?.zapsign_document_id) {
                throw new BadRequestException('Contrato n√£o possui documento no ZapSign');
            }

            const apiKey = process.env.ZAPSIGN_API_KEY;
            const apiUrl = process.env.ZAPSIGN_API_URL || 'https://api.zapsign.com.br';

            if (!apiKey) {
                throw new BadRequestException('ZAPSIGN_API_KEY n√£o configurada');
            }

            const response = await axios.get(`${apiUrl}/api/v1/documents/${contrato.zapsign_document_id}`, {
                headers: {
                    Authorization: `Bearer ${apiKey}`,
                    'Content-Type': 'application/json',
                },
            });

            const documentStatus = response.data;

            await this.uow.turmasAlunosTreinamentosContratosRP.update(
                { id: contratoId },
                {
                    zapsign_document_status: documentStatus as any,
                    zapsign_signers_data: (documentStatus as any).signers || [],
                },
            );

            console.log(`Status do documento ${contrato.zapsign_document_id} atualizado`);
            return documentStatus;
        } catch (error) {
            console.error('Erro ao consultar status do ZapSign:', error);
            throw new BadRequestException('Erro ao consultar status do documento no ZapSign');
        }
    }

    /**
     * Exclui um documento do ZapSign
     */
    async excluirDocumentoZapSign(contratoId: string): Promise<void> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato?.zapsign_document_id) {
                throw new BadRequestException('Contrato n√£o possui documento no ZapSign');
            }

            const apiKey = process.env.ZAPSIGN_API_KEY;
            const apiUrl = process.env.ZAPSIGN_API_URL || 'https://api.zapsign.com.br';

            if (!apiKey) {
                throw new BadRequestException('ZAPSIGN_API_KEY n√£o configurada');
            }

            await axios.delete(`${apiUrl}/api/v1/documents/${contrato.zapsign_document_id}`, {
                headers: {
                    Authorization: `Bearer ${apiKey}`,
                    'Content-Type': 'application/json',
                },
            });

            await this.uow.turmasAlunosTreinamentosContratosRP.update(
                { id: contratoId },
                {
                    zapsign_document_id: null,
                    zapsign_signers_data: null,
                    zapsign_document_status: null,
                },
            );

            console.log(`Documento ${contrato.zapsign_document_id} exclu√≠do do ZapSign`);
        } catch (error) {
            console.error('Erro ao excluir documento do ZapSign:', error);
            throw new BadRequestException('Erro ao excluir documento do ZapSign');
        }
    }

    /**
     * Sincroniza status de todos os contratos com ZapSign
     */
    async sincronizarTodosContratosZapSign(): Promise<void> {
        try {
            const contratos = await this.uow.turmasAlunosTreinamentosContratosRP.find({
                where: { zapsign_document_id: Not(IsNull()) },
            });

            console.log(`Sincronizando ${contratos.length} contratos com ZapSign...`);

            for (const contrato of contratos) {
                try {
                    await this.consultarStatusZapSign(contrato.id);
                    console.log(`‚úÖ Contrato ${contrato.id} sincronizado`);
                } catch (error) {
                    console.error(`‚ùå Erro ao sincronizar contrato ${contrato.id}:`, error);
                }
            }

            console.log('Sincroniza√ß√£o completa!');
        } catch (error) {
            console.error('Erro na sincroniza√ß√£o geral:', error);
            throw new BadRequestException('Erro na sincroniza√ß√£o com ZapSign');
        }
    }

    /**
     * Atualiza dados do ZapSign para contratos existentes que n√£o possuem esses dados
     */
    async atualizarDadosZapSignContratosExistentes(): Promise<void> {
        try {
            console.log('üîÑ Buscando contratos sem dados do ZapSign...');

            const contratos = await this.uow.turmasAlunosTreinamentosContratosRP.find({
                where: {
                    zapsign_document_id: null,
                    dados_contrato: Not(IsNull()),
                },
            });

            console.log(`üìã Encontrados ${contratos.length} contratos para atualizar`);

            for (const contrato of contratos) {
                try {
                    const idZapSign = contrato.dados_contrato?.contrato?.id_documento_zapsign;

                    if (idZapSign) {
                        console.log(`üîÑ Atualizando contrato ${contrato.id} com ID ZapSign: ${idZapSign}`);

                        const documentoZapSign = await this.zapSignService.getDocument(idZapSign);

                        if (documentoZapSign) {
                            await this.uow.turmasAlunosTreinamentosContratosRP.update(
                                { id: contrato.id },
                                {
                                    zapsign_document_id: documentoZapSign.token,
                                    zapsign_signers_data: documentoZapSign.signers || [],
                                    zapsign_document_status: {
                                        documentId: documentoZapSign.token,
                                        openId: documentoZapSign.open_id,
                                        signers: documentoZapSign.signers || [],
                                        status: documentoZapSign.status,
                                        createdAt: documentoZapSign.created_at,
                                        originalFile: documentoZapSign.original_file,
                                        signedFile: documentoZapSign.signed_file,
                                    },
                                },
                            );

                            console.log(`‚úÖ Contrato ${contrato.id} atualizado com sucesso`);
                        }
                    }
                } catch (error) {
                    console.error(`‚ùå Erro ao atualizar contrato ${contrato.id}:`, error);
                }
            }

            console.log('‚úÖ Atualiza√ß√£o de contratos existentes conclu√≠da');
        } catch (error) {
            console.error('Erro ao atualizar dados do ZapSign para contratos existentes:', error);
            throw new BadRequestException('Erro ao atualizar dados do ZapSign');
        }
    }

    /**
     * Processa assinatura completa recebida via webhook
     */
    private async processarAssinaturaCompleta(contratoId: string, signerData: any): Promise<void> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato) {
                console.warn(`‚ö†Ô∏è Contrato ${contratoId} n√£o encontrado`);
                return;
            }

            const signerName = signerData?.name || signerData?.signer_name;
            const signerEmail = signerData?.email || signerData?.signer_email;

            console.log(`‚úÖ Assinatura completa recebida: ${signerName} (${signerEmail})`);

            let signerInterno: 'aluno' | 'testemunha1' | 'testemunha2' | null = null;

            const alunoNome = contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.nome;
            const alunoEmail = contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.email;

            if (signerName === alunoNome || signerEmail === alunoEmail) {
                signerInterno = 'aluno';
            } else {
                const testemunha1Nome = contrato.dados_contrato?.testemunhas?.testemunha_um?.nome;
                const testemunha1Email = contrato.dados_contrato?.testemunhas?.testemunha_um?.email;

                if (signerName === testemunha1Nome || signerEmail === testemunha1Email) {
                    signerInterno = 'testemunha1';
                } else {
                    const testemunha2Nome = contrato.dados_contrato?.testemunhas?.testemunha_dois?.nome;
                    const testemunha2Email = contrato.dados_contrato?.testemunhas?.testemunha_dois?.email;

                    if (signerName === testemunha2Nome || signerEmail === testemunha2Email) {
                        signerInterno = 'testemunha2';
                    }
                }
            }

            if (signerInterno) {
                await this.atualizarStatusAssinaturaLocal(contratoId, signerInterno, EStatusAssinaturasContratos.ASSINADO);
                console.log(`‚úÖ Status ${signerInterno} atualizado para ASSINADO via webhook`);
            } else {
                console.warn(`‚ö†Ô∏è Signer ${signerName} n√£o mapeado para nenhum signer interno`);
            }
        } catch (error) {
            console.error('‚ùå Erro ao processar assinatura completa:', error);
            throw error;
        }
    }

    /**
     * Garante que o contrato possui zapsign_document_id
     */
    async garantirZapSignDocumentId(contratoId: string): Promise<boolean> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato) {
                throw new NotFoundException('Contrato n√£o encontrado');
            }

            // Se j√° tem zapsign_document_id, retornar true
            if (contrato.zapsign_document_id) {
                console.log(`‚úÖ Contrato ${contratoId} j√° possui zapsign_document_id: ${contrato.zapsign_document_id}`);
                return true;
            }

            // Tentar extrair do dados_contrato
            const idZapSign = contrato.dados_contrato?.contrato?.id_documento_zapsign;

            if (idZapSign) {
                console.log(`üîÑ Atualizando contrato ${contratoId} com zapsign_document_id: ${idZapSign}`);

                await this.uow.turmasAlunosTreinamentosContratosRP.update(
                    { id: contratoId },
                    {
                        zapsign_document_id: idZapSign,
                    },
                );

                console.log(`‚úÖ zapsign_document_id atualizado para contrato ${contratoId}`);
                return true;
            }

            console.warn(`‚ö†Ô∏è Contrato ${contratoId} n√£o possui zapsign_document_id`);
            return false;
        } catch (error) {
            console.error('Erro ao garantir zapsign_document_id:', error);
            throw new BadRequestException('Erro ao garantir zapsign_document_id');
        }
    }

    /**
     * Verifica dados do ZapSign para um contrato
     */
    async verificarDadosZapSign(contratoId: string): Promise<any> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato) {
                throw new NotFoundException('Contrato n√£o encontrado');
            }

            const resultado = {
                contratoId: contrato.id,
                zapsign_document_id: contrato.zapsign_document_id,
                zapsign_document_id_em_dados_contrato: contrato.dados_contrato?.contrato?.id_documento_zapsign,
                zapsign_signers_data: contrato.zapsign_signers_data,
                zapsign_document_status: contrato.zapsign_document_status,
                possui_zapsign_document_id: !!contrato.zapsign_document_id,
                possui_dados_zapsign: !!(contrato.zapsign_signers_data || contrato.zapsign_document_status),
            };

            console.log('Dados ZapSign do contrato:', resultado);
            return resultado;
        } catch (error) {
            console.error('Erro ao verificar dados ZapSign:', error);
            throw new BadRequestException('Erro ao verificar dados ZapSign');
        }
    }

    /**
     * Verifica e corrige o zapsign_document_id se estiver faltando
     */
    async verificarECorrigirZapSignDocumentId(contratoId: string): Promise<boolean> {
        try {
            console.log(`üîç Verificando zapsign_document_id para contrato ${contratoId}...`);

            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato) {
                throw new NotFoundException('Contrato n√£o encontrado');
            }

            // Se j√° tem zapsign_document_id, n√£o precisa corrigir
            if (contrato.zapsign_document_id) {
                console.log(`‚úÖ Contrato ${contratoId} j√° possui zapsign_document_id: ${contrato.zapsign_document_id}`);
                return true;
            }

            console.log(`‚ö†Ô∏è Contrato ${contratoId} n√£o possui zapsign_document_id, tentando corrigir...`);

            // Tentar diferentes caminhos para encontrar o ID
            const idDocumentoZapSign = contrato.dados_contrato?.contrato?.id_documento_zapsign;
            const idDocumentoZapSignAlt1 = contrato.dados_contrato?.id_documento_zapsign;
            const idDocumentoZapSignAlt2 = contrato.dados_contrato?.documento_final?.id_zapsign;

            const idFinal = idDocumentoZapSign || idDocumentoZapSignAlt1 || idDocumentoZapSignAlt2;

            if (idFinal) {
                console.log(`‚úÖ ID do ZapSign encontrado: ${idFinal}`);
                console.log(`üîÑ Atualizando contrato ${contratoId}...`);

                // Buscar dados do documento no ZapSign
                try {
                    const documentoZapSign = await this.zapSignService.getDocument(idFinal);

                    await this.uow.turmasAlunosTreinamentosContratosRP.update(
                        { id: contratoId },
                        {
                            zapsign_document_id: idFinal,
                            zapsign_signers_data: documentoZapSign.signers || [],
                            zapsign_document_status: {
                                documentId: documentoZapSign.token,
                                openId: documentoZapSign.open_id,
                                signers: documentoZapSign.signers || [],
                                status: documentoZapSign.status,
                                createdAt: documentoZapSign.created_at,
                                originalFile: documentoZapSign.original_file,
                                signedFile: documentoZapSign.signed_file,
                            },
                        },
                    );

                    console.log(`‚úÖ Contrato ${contratoId} corrigido com sucesso`);
                    return true;
                } catch (zapSignError) {
                    console.warn(`‚ö†Ô∏è Erro ao buscar documento no ZapSign, salvando apenas o ID:`, zapSignError);

                    // Salvar apenas o ID mesmo sem conseguir buscar os dados completos
                    await this.uow.turmasAlunosTreinamentosContratosRP.update(
                        { id: contratoId },
                        {
                            zapsign_document_id: idFinal,
                        },
                    );

                    console.log(`‚úÖ zapsign_document_id salvo para contrato ${contratoId}`);
                    return true;
                }
            }

            console.warn(`‚ùå N√£o foi poss√≠vel encontrar ID do ZapSign para contrato ${contratoId}`);
            return false;
        } catch (error) {
            console.error('Erro ao verificar e corrigir zapsign_document_id:', error);
            throw new BadRequestException('Erro ao verificar e corrigir zapsign_document_id');
        }
    }

    /**
     * Processa webhook do ZapSign quando uma assinatura √© realizada
     */
    async processarWebhookZapSign(webhookData: any): Promise<void> {
        try {
            console.log('üîî Processando webhook ZapSign:', JSON.stringify(webhookData, null, 2));

            // Verificar se √© um evento de assinatura
            if (webhookData.event === 'document.signed' || webhookData.event === 'signer.signed') {
                const documentToken = webhookData.document?.token || webhookData.document_id;

                if (!documentToken) {
                    console.error('‚ùå Webhook ZapSign sem token do documento');
                    return;
                }

                console.log(`üìÑ Processando assinatura para documento ZapSign: ${documentToken}`);

                // Buscar contrato pelo token do ZapSign
                const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                    where: { zapsign_document_id: documentToken },
                });

                if (!contrato) {
                    console.error(`‚ùå Contrato n√£o encontrado para documento ZapSign: ${documentToken}`);
                    return;
                }

                console.log(`‚úÖ Contrato encontrado: ${contrato.id}`);

                // Buscar dados atualizados do ZapSign
                const documentoZapSign = await this.buscarDocumentoZapSign(contrato.id);

                if (!documentoZapSign) {
                    console.error(`‚ùå N√£o foi poss√≠vel buscar dados atualizados do ZapSign para contrato ${contrato.id}`);
                    return;
                }

                // Atualizar status das assinaturas no banco local
                await this.atualizarStatusAssinaturasDoZapSign(contrato.id, documentoZapSign);

                console.log(`‚úÖ Webhook ZapSign processado com sucesso para contrato ${contrato.id}`);
            }
        } catch (error) {
            console.error('‚ùå Erro ao processar webhook ZapSign:', error);
            throw error;
        }
    }

    /**
     * Atualiza status das assinaturas baseado nos dados do ZapSign
     */
    async atualizarStatusAssinaturasDoZapSign(contratoId: string, documentoZapSign: any): Promise<void> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato) {
                throw new Error(`Contrato ${contratoId} n√£o encontrado`);
            }

            const updateData: any = {};

            // Atualizar dados do ZapSign
            updateData.zapsign_document_status = {
                documentId: contrato.zapsign_document_id,
                openId: null,
                status: documentoZapSign.status || 'pending',
                createdAt: documentoZapSign.created_at || new Date().toISOString(),
                originalFile: documentoZapSign.file_url || null,
                signedFile: null,
                signers: documentoZapSign.signers || [],
            };

            updateData.zapsign_signers_data = documentoZapSign.signers;

            // Verificar status de cada signat√°rio
            if (documentoZapSign.signers && Array.isArray(documentoZapSign.signers)) {
                for (const signer of documentoZapSign.signers) {
                    const signerEmail = signer.email?.toLowerCase();
                    const signerName = signer.nome || 'Signat√°rio';
                    const signerStatus = signer.status || 'new';

                    if (!signerEmail) continue;

                    // Verificar se √© o aluno
                    const alunoEmail = contrato.id_turma_aluno_treinamento_fk?.id_turma_aluno_fk?.id_aluno_fk?.email?.toLowerCase();
                    if (alunoEmail && signerEmail === alunoEmail && signerStatus === 'signed') {
                        updateData.status_ass_aluno = EStatusAssinaturasContratos.ASSINADO;
                        updateData.data_ass_aluno = new Date();
                        console.log(`‚úÖ Aluno ${signerName} assinou no ZapSign`);
                    }

                    // Verificar se √© testemunha 1
                    const testemunha1Email = contrato.dados_contrato?.testemunhas?.testemunha_um?.email?.toLowerCase();
                    if (testemunha1Email && signerEmail === testemunha1Email && signerStatus === 'signed') {
                        updateData.status_ass_test_um = EStatusAssinaturasContratos.ASSINADO;
                        updateData.data_ass_test_um = new Date();
                        console.log(`‚úÖ Testemunha 1 ${signerName} assinou no ZapSign`);
                    }

                    // Verificar se √© testemunha 2
                    const testemunha2Email = contrato.dados_contrato?.testemunhas?.testemunha_dois?.email?.toLowerCase();
                    if (testemunha2Email && signerEmail === testemunha2Email && signerStatus === 'signed') {
                        updateData.status_ass_test_dois = EStatusAssinaturasContratos.ASSINADO;
                        updateData.data_ass_test_dois = new Date();
                        console.log(`‚úÖ Testemunha 2 ${signerName} assinou no ZapSign`);
                    }
                }
            }

            // Atualizar contrato no banco
            await this.uow.turmasAlunosTreinamentosContratosRP.update({ id: contratoId }, updateData);

            console.log(`‚úÖ Status das assinaturas atualizado para contrato ${contratoId}`);
        } catch (error) {
            console.error(`‚ùå Erro ao atualizar status das assinaturas para contrato ${contratoId}:`, error);
            throw error;
        }
    }

    /**
     * Sincroniza manualmente as assinaturas de um contrato com o ZapSign
     */
    async sincronizarAssinaturasComZapSign(contratoId: string): Promise<{ message: string; sincronizado: boolean }> {
        try {
            console.log(`üîÑ Iniciando sincroniza√ß√£o manual com ZapSign para contrato ${contratoId}`);

            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato) {
                throw new NotFoundException(`Contrato ${contratoId} n√£o encontrado`);
            }

            if (!contrato.zapsign_document_id) {
                throw new BadRequestException(`Contrato ${contratoId} n√£o possui documento no ZapSign`);
            }

            console.log(`üìÑ Contrato encontrado: ${contratoId}, ZapSign ID: ${contrato.zapsign_document_id}`);

            // Tentar m√∫ltiplas abordagens de sincroniza√ß√£o
            let sincronizado = false;
            let ultimoErro = null;

            // Abordagem 1: Buscar dados atualizados do ZapSign
            try {
                console.log(`üîç Tentativa 1: Buscando dados atualizados do ZapSign...`);
                const documentoZapSign = await this.buscarDocumentoZapSign(contratoId);

                if (documentoZapSign) {
                    await this.atualizarStatusAssinaturasDoZapSign(contratoId, documentoZapSign);
                    sincronizado = true;
                    console.log(`‚úÖ Sincroniza√ß√£o via busca de dados conclu√≠da`);
                }
            } catch (erro1) {
                console.warn(`‚ö†Ô∏è Tentativa 1 falhou:`, erro1 instanceof Error ? erro1.message : 'Erro desconhecido');
                ultimoErro = erro1;
            }

            // Abordagem 2: Tentar sincroniza√ß√£o via webhook simulado
            if (!sincronizado) {
                try {
                    console.log(`üîç Tentativa 2: Simulando webhook do ZapSign...`);
                    await this.simularWebhookZapSign(contratoId);
                    sincronizado = true;
                    console.log(`‚úÖ Sincroniza√ß√£o via webhook simulado conclu√≠da`);
                } catch (erro2) {
                    console.warn(`‚ö†Ô∏è Tentativa 2 falhou:`, erro2 instanceof Error ? erro2.message : 'Erro desconhecido');
                    ultimoErro = erro2;
                }
            }

            // Abordagem 3: For√ßar atualiza√ß√£o baseada no estado local
            if (!sincronizado) {
                try {
                    console.log(`üîç Tentativa 3: For√ßando atualiza√ß√£o baseada no estado local...`);
                    await this.forcarAtualizacaoLocal(contratoId);
                    sincronizado = true;
                    console.log(`‚úÖ Atualiza√ß√£o local for√ßada conclu√≠da`);
                } catch (erro3) {
                    console.warn(`‚ö†Ô∏è Tentativa 3 falhou:`, erro3 instanceof Error ? erro3.message : 'Erro desconhecido');
                    ultimoErro = erro3;
                }
            }

            if (sincronizado) {
                console.log(`‚úÖ Sincroniza√ß√£o manual conclu√≠da para contrato ${contratoId}`);
                return {
                    message: 'Sincroniza√ß√£o com ZapSign realizada com sucesso',
                    sincronizado: true,
                };
            } else {
                console.error(`‚ùå Todas as tentativas de sincroniza√ß√£o falharam para contrato ${contratoId}`);
                throw ultimoErro || new Error('Falha na sincroniza√ß√£o com ZapSign');
            }
        } catch (error) {
            console.error(`‚ùå Erro na sincroniza√ß√£o manual com ZapSign para contrato ${contratoId}:`, error);
            throw error;
        }
    }

    /**
     * Obt√©m os links de assinatura do ZapSign para um contrato
     */
    async obterLinksAssinaturaZapSign(contratoId: string): Promise<{ links: any[]; documento: any }> {
        try {
            console.log(`üîó Obtendo links de assinatura ZapSign para contrato ${contratoId}`);

            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato) {
                throw new NotFoundException(`Contrato ${contratoId} n√£o encontrado`);
            }

            if (!contrato.zapsign_document_id) {
                throw new BadRequestException(`Contrato ${contratoId} n√£o possui documento no ZapSign`);
            }

            // Buscar dados atualizados do ZapSign
            const documentoZapSign = await this.buscarDocumentoZapSign(contratoId);

            if (!documentoZapSign) {
                throw new BadRequestException(`N√£o foi poss√≠vel buscar dados do ZapSign para contrato ${contratoId}`);
            }

            // Mapear signers para estrutura correta
            const links = documentoZapSign.signers.map((signer: any) => ({
                nome: signer.nome || 'Signat√°rio',
                email: signer.email,
                status: signer.status || 'new',
                link_assinatura: signer.link_assinatura || signer.sign_url || '',
                token: signer.token || '',
                assinado_em: signer.assinado_em || signer.signed_at || null,
            }));

            console.log(`‚úÖ Links de assinatura obtidos para contrato ${contratoId}:`, links);

            return {
                links,
                documento: {
                    token: contrato.zapsign_document_id,
                    open_id: null,
                    nome: documentoZapSign.nome_documento || 'Documento',
                    status: documentoZapSign.status || 'pending',
                    criado_em: documentoZapSign.created_at || new Date().toISOString(),
                    arquivo_original: documentoZapSign.file_url || null,
                    arquivo_assinado: null,
                },
            };
        } catch (error) {
            console.error(`‚ùå Erro ao obter links de assinatura ZapSign para contrato ${contratoId}:`, error);
            throw error;
        }
    }

    /**
     * Simula um webhook do ZapSign para for√ßar sincroniza√ß√£o
     */
    async simularWebhookZapSign(contratoId: string): Promise<void> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato || !contrato.zapsign_document_id) {
                throw new Error('Contrato n√£o encontrado ou sem documento ZapSign');
            }

            // Simular dados de webhook baseados no estado atual do contrato
            const webhookData = {
                event: 'signer.signed',
                document: {
                    token: contrato.zapsign_document_id,
                    status: 'pending',
                },
                signer: {
                    name: 'Signat√°rio Local',
                    email: 'local@signature.com',
                    status: 'signed',
                    signed_at: new Date().toISOString(),
                },
            };

            console.log(`üîÑ Simulando webhook para contrato ${contratoId}:`, webhookData);
            await this.processarWebhookZapSign(webhookData);
        } catch (error) {
            console.error(`‚ùå Erro ao simular webhook para contrato ${contratoId}:`, error);
            throw error;
        }
    }

    /**
     * For√ßa atualiza√ß√£o baseada no estado local do contrato
     */
    async forcarAtualizacaoLocal(contratoId: string): Promise<void> {
        try {
            const contrato = await this.uow.turmasAlunosTreinamentosContratosRP.findOne({
                where: { id: contratoId },
            });

            if (!contrato) {
                throw new Error('Contrato n√£o encontrado');
            }

            console.log(`üîÑ For√ßando atualiza√ß√£o local para contrato ${contratoId}`);

            // Atualizar dados do ZapSign baseados no estado local
            const updateData: any = {};

            // Atualizar zapsign_document_status com dados locais
            updateData.zapsign_document_status = {
                documentId: contrato.zapsign_document_id,
                openId: null,
                status: 'pending', // Manter como pending at√© sincroniza√ß√£o completa
                createdAt: contrato.criado_em?.toISOString() || new Date().toISOString(),
                originalFile: null,
                signedFile: null,
                signers: contrato.zapsign_signers_data || [],
            };

            // Atualizar status das assinaturas baseado no estado local
            if (contrato.status_ass_aluno === EStatusAssinaturasContratos.ASSINADO) {
                console.log(`‚úÖ Aluno j√° assinado localmente`);
            }

            if (contrato.status_ass_test_um === EStatusAssinaturasContratos.ASSINADO) {
                console.log(`‚úÖ Testemunha 1 j√° assinada localmente`);
            }

            if (contrato.status_ass_test_dois === EStatusAssinaturasContratos.ASSINADO) {
                console.log(`‚úÖ Testemunha 2 j√° assinada localmente`);
            }

            // Atualizar contrato no banco
            await this.uow.turmasAlunosTreinamentosContratosRP.update({ id: contratoId }, updateData);

            console.log(`‚úÖ Atualiza√ß√£o local for√ßada conclu√≠da para contrato ${contratoId}`);
        } catch (error) {
            console.error(`‚ùå Erro ao for√ßar atualiza√ß√£o local para contrato ${contratoId}:`, error);
            throw error;
        }
    }
}
